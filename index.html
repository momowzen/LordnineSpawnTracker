<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@700&display=swap"
      rel="stylesheet"
    />
    <title>LORDNINE TRACKER</title>
    <link
      href="assets/images/logo5.png"
      rel="icon"
      sizes="64x64"
      type="image/png"
    />
    <style>
      :root {
        --bg: #0a0a0a;
        --bg-card: #151515;
        --bg-hover: #1a1a1a;
        --border: #252525;
        --border-bright: #333;
        --text: #e0e0e0;
        --text-dim: #808080;
        --accent: #00f0ff;
        --accent-dim: #008a95;
        --success: #00ff88;
        --warning: #ff6b00;
        --danger: #ff3366;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        height: 100%;
        overflow: hidden;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: var(--bg);
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        font-size: 14px;
      }

      .container {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 16px;
        max-width: 1400px;
        margin: 0 auto;
        gap: 16px;
      }

      /* Header */
      header.app-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: var(--bg-card);
        border: 1px solid var(--border);
        padding: 12px 20px;
        border-radius: 6px;
      }

      .app-title {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .app-title-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .logo-img {
        height: 40px;
        width: auto;
        opacity: 0.9;
      }

      .main-title {
        font-family: "Orbitron", sans-serif;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 1px;
        color: var(--accent);
        text-transform: uppercase;
      }

      .warning-text {
        font-size: 10px;
        font-weight: 600;
        color: var(--warning);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .header-controls {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .search-wrapper {
        position: relative;
        width: 220px;
      }

      .search {
        width: 100%;
        background: var(--bg);
        border: 1px solid var(--border);
        padding: 8px 32px 8px 12px;
        border-radius: 4px;
        color: var(--text);
        font-size: 13px;
        transition: all 0.2s;
      }

      .search:focus {
        outline: none;
        border-color: var(--accent);
        background: var(--bg-hover);
      }

      .search::placeholder {
        color: var(--text-dim);
      }

      .search-clear {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: var(--text-dim);
        cursor: pointer;
        padding: 4px;
        display: none;
        align-items: center;
        justify-content: center;
        border-radius: 3px;
        transition: all 0.2s;
      }

      .search-clear:hover {
        color: var(--accent);
        background: rgba(255, 255, 255, 0.05);
      }

      .search-clear.visible {
        display: flex;
      }

      .search-clear svg {
        width: 16px;
        height: 16px;
      }

      .settings {
        background: transparent;
        border: none;
        padding: 8px;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 3px;
        transition: all 0.2s;
      }

      .settings .line {
        width: 20px;
        height: 2px;
        background: var(--text);
        border-radius: 1px;
        transition: all 0.2s;
      }

      .settings:hover .line {
        background: var(--accent);
      }

      /* Main Layout */
      .main {
        flex: 1;
        display: grid;
        grid-template-columns: 1fr 380px;
        gap: 16px;
        min-height: 0;
      }

      /* Mobile responsive */
      @media (max-width: 768px) {
        .main {
          grid-template-columns: 1fr;
        }

        .right-column {
          flex-direction: row;
          gap: 0;
          flex-shrink: 0;
        }

        #nextBoss {
          flex: 0 0 auto;
          min-height: 80px;
        }

        #timersPanel {
          flex: 0 0 auto;
          border-top: 1px solid var(--border);
          border-bottom: none;
          border-left: none;
          border-right: none;
          border-radius: 0;
        }

        #timersPanel .card-body {
          display: none;
          max-height: 40vh;
          overflow-y: auto;
        }

        #timersPanel.expanded .card-body {
          display: block;
        }

        #timersPanel .card-header {
          cursor: pointer;
          user-select: none;
          transition: background 0.2s;
        }

        #timersPanel .card-header:hover {
          background: var(--bg-hover);
        }
      }



      /* Card Styles */
      .card {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 6px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .card-header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        font-weight: 600;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-dim);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .card-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
      }

      /* Sort Button */
      .sort-btn {
        padding: 5px 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        color: var(--text-dim);
        font-size: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        backdrop-filter: blur(4px);
      }

      .sort-btn:hover {
        background: rgba(0, 240, 255, 0.1);
        border-color: rgba(0, 240, 255, 0.3);
        color: var(--accent);
        transform: translateY(-1px);
      }

      /* Next Boss */
      #nextBoss {
        background: linear-gradient(135deg, var(--bg-card) 0%, #1a1a1a 100%);
        border: 1px solid var(--accent-dim);
        padding: 24px 16px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        min-height: 80px;
      }

      .next-boss-name {
        font-size: clamp(20px, 5vw, 28px);
        font-weight: 700;
        color: var(--accent);
        white-space: nowrap;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .next-boss-time {
        font-size: clamp(12px, 3vw, 16px);
        color: var(--text-dim);
        font-weight: 500;
        white-space: nowrap;
      }

      /* Boss List */
      #bossList {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        grid-auto-rows: auto;
        gap: 12px;
      }

      .boss {
        position: relative;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        transition: all 0.2s;
        cursor: pointer;
        height: 280px;
      }

      .boss:hover {
        border-color: var(--accent-dim);
        transform: translateY(-2px);
      }

      .boss:hover .name {
        color: var(--accent);
        text-shadow: 0 0 8px rgba(0, 240, 255, 0.6);
      }

      .boss:hover .sub {
        color: var(--danger);
        text-shadow: 0 0 8px rgba(255, 51, 102, 0.6);
      }

      .boss-background {
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        opacity: 0.5;
        transition: opacity 0.2s;
        pointer-events: none;
        filter: brightness(1.2);
      }

      .boss:hover .boss-background {
        opacity: 0.7;
        filter: brightness(1.8);
      }

      .boss-overlay {
        position: absolute;
        inset: 0;
        background: linear-gradient(
          to bottom,
          rgba(10, 10, 10, 0.4),
          rgba(10, 10, 10, 0.95)
        );
        pointer-events: none;
      }

      .boss-content {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        padding: 6px 12px 12px 12px;
        z-index: 1;
        text-align: center;
      }

      .boss-info {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding-top: 0px;
      }

      .boss .name {
        font-weight: 700;
        font-size: 15px;
        color: var(--text);
        margin-bottom: 4px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      }

      .boss .sub {
        font-size: 11px;
        color: var(--text-dim);
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      }

      .boss-actions {
        display: flex;
        flex-direction: row;
        justify-content: center;
        gap: 4px;
        width: 100%;
        margin-top: auto;
      }

      /* Buttons */
      .kbtn {
        padding: 7px 8px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.03);
        color: var(--text-dim);
        border-radius: 4px;
        font-size: clamp(9px, 1.5vw, 10px);
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 0.3px;
        white-space: nowrap;
        flex: 1 1 0;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
      }

      .kbtn-icon {
        display: none;
        width: 16px;
        height: 16px;
        flex-shrink: 0;
      }

      .kbtn-text {
        display: inline;
      }

      .kbtn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.25);
      }

      .kbtn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .kbtn[data-action="mark"]:hover:not(:disabled) {
        color: var(--accent);
      }

      .kbtn[data-action="cancel"]:hover {
        color: var(--danger);
      }

      .kbtn[data-action="set"]:hover {
        color: var(--warning);
      }

      /* Active Timers */
      .timer {
        background: var(--bg);
        border: 1px solid var(--border);
        border-left: 3px solid var(--accent);
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 8px;
        position: relative;
        transition: all 0.2s;
      }

      .timer:hover {
        background: var(--bg-hover);
        border-color: var(--accent);
      }

      .timer-remaining {
        font-size: 11px;
        color: var(--warning);
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px solid rgba(255, 107, 0, 0.2);
        opacity: 0;
        max-height: 0;
        overflow: hidden;
        transition: opacity 0.3s ease, max-height 0.3s ease, margin-top 0.3s ease, padding-top 0.3s ease;
      }

      .timer:hover .timer-remaining {
        opacity: 1;
        max-height: 30px;
      }

      .timer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .timer-name {
        font-weight: 600;
        font-size: 14px;
        color: var(--text);
      }

      .timer-time {
        font-size: 12px;
        color: var(--accent);
        font-weight: 500;
      }

      .timer-spawn {
        font-size: 11px;
        color: var(--text-dim);
        margin-top: 4px;
      }

      /* Ready to respawn state */
      .timer.ready {
        border-color: var(--success);
        border-left-color: var(--success);
        background: rgba(0, 255, 136, 0.05);
        box-shadow: 0 0 12px rgba(0, 255, 136, 0.2);
        animation: timerReadyPulse 2s ease-in-out infinite;
      }

      @keyframes timerReadyPulse {
        0%,
        100% {
          box-shadow: 0 0 12px rgba(0, 255, 136, 0.2);
        }
        50% {
          box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }
      }

      /* Modal */
      .modal-backdrop {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(4px);
        z-index: 10000;
        align-items: center;
        justify-content: center;
      }

      .modal {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 6px;
        width: 90%;
        max-width: 400px;
        max-height: 80vh;
        overflow-y: auto;
      }

      .modal-header {
        padding: 16px 20px;
        border-bottom: 1px solid var(--border);
        font-weight: 600;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .modal-body {
        padding: 20px;
      }

      .modal-section {
        margin-bottom: 24px;
      }

      .modal-section:last-child {
        margin-bottom: 0;
      }

      .modal-section h3 {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-dim);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 12px;
      }

      .modal-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .modal-actions .kbtn {
        flex: 1;
        min-width: 80px;
      }

      .modal-input {
        width: 100%;
        background: var(--bg);
        border: 1px solid var(--border);
        padding: 10px 12px;
        border-radius: 4px;
        color: var(--text);
        font-size: 13px;
        margin-bottom: 8px;
      }

      .modal-input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Time Picker Modal */
      .time-picker-label {
        font-size: 12px;
        color: var(--text-dim);
        margin-bottom: 6px;
        display: block;
      }

      .datetime-input {
        width: 100%;
        background: var(--bg);
        border: 1px solid var(--border);
        padding: 10px 12px;
        border-radius: 4px;
        color: var(--text);
        font-size: 13px;
        font-family: inherit;
      }

      .datetime-input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Online Counter */
      .online-users {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: 8px 14px;
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        z-index: 1000;
      }

      .online-users:hover {
        border-color: var(--accent);
        transform: translateY(-2px);
      }

      .online-users::before {
        content: "";
        width: 8px;
        height: 8px;
        background: var(--success);
        border-radius: 50%;
        box-shadow: 0 0 8px var(--success);
      }

      .online-users.notify {
        animation: pulse 1s infinite;
        border-color: var(--warning);
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      /* Chat */
      .chat-box {
        position: fixed;
        bottom: 70px;
        right: 20px;
        width: 350px;
        height: 450px;
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 6px;
        display: none;
        flex-direction: column;
        z-index: 1001;
        overflow: hidden;
      }

      .chat-box.active {
        display: flex;
      }

      .chat-box.hidden {
        display: none;
      }

      .chat-header {
        padding: 12px 16px;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .chat-minimize-btn {
        background: transparent;
        border: none;
        color: var(--text-dim);
        font-size: 20px;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s;
      }

      .chat-minimize-btn:hover {
        color: var(--accent);
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .chat-message {
        font-size: 12px;
        line-height: 1.4;
        color: var(--text);
      }

      .chat-input-area {
        padding: 12px;
        background: var(--bg);
        border-top: 1px solid var(--border);
        display: flex;
        gap: 8px;
      }

      .chat-input-area input {
        flex: 1;
        background: var(--bg-card);
        border: 1px solid var(--border);
        padding: 8px 10px;
        border-radius: 4px;
        color: var(--text);
        font-size: 12px;
      }

      .chat-input-area input:focus {
        outline: none;
        border-color: var(--accent);
      }

      .chat-input-area button {
        padding: 8px 16px;
        background: var(--accent);
        border: none;
        border-radius: 4px;
        color: var(--bg);
        font-weight: 600;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .chat-input-area button:hover {
        background: var(--success);
      }

      /* Loading */
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: var(--bg);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100000;
        flex-direction: column;
        gap: 16px;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid var(--border);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        color: var(--text-dim);
        font-size: 13px;
        font-weight: 500;
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, var(--danger), #cc2952);
        border-radius: 4px;
        border: 2px solid var(--bg);
      }

      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, #ff5577, var(--danger));
        box-shadow: 0 0 6px rgba(255, 51, 102, 0.5);
      }

      /* Firefox scrollbar */
      * {
        scrollbar-width: thin;
        scrollbar-color: var(--danger) var(--bg);
      }

      /* Mobile */
      @media (max-width: 768px) {
        .container {
          padding: 12px;
          gap: 12px;
        }

        .main {
          grid-template-columns: 1fr;
          grid-template-rows: auto 1fr auto;
        }

        #bossList {
          grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
          gap: 10px;
        }

        .boss {
          height: 220px;
        }

        .boss .name {
          font-size: 13px;
        }

        .boss .sub {
          font-size: 10px;
        }

        .kbtn {
          font-size: clamp(8px, 1.8vw, 9px);
          padding: 8px 6px;
          letter-spacing: 0.2px;
        }

        .kbtn-icon {
          display: block;
          width: 18px;
          height: 18px;
        }

        .kbtn-text {
          display: none;
        }

        header.app-header {
          flex-direction: column;
          align-items: stretch;
          gap: 12px;
          padding: 12px 16px;
        }

        .app-title {
          width: 100%;
          justify-content: flex-start;
        }

        .app-title-text {
          flex-direction: row;
          align-items: baseline;
          gap: 6px;
        }

        .warning-text {
          font-size: 9px;
        }

        .header-controls {
          width: 100%;
          display: flex;
          gap: 8px;
        }

        .search-wrapper {
          flex: 1;
          min-width: 0;
          width: auto;
        }

        .search {
          width: 100%;
        }

        .settings {
          flex-shrink: 0;
        }

        .main-title {
          font-size: 16px;
        }

        .logo-img {
          height: 36px;
        }

        .chat-box {
          width: calc(100vw - 24px);
          right: 12px;
        }

        .right-column {
          display: contents;
        }

        #nextBoss {
          order: 1;
          padding: 20px 12px;
          min-height: 70px;
          gap: 6px;
        }

        #bossListPanel {
          order: 2;
        }

        #timersPanel {
          order: 3;
          max-height: 30vh;
        }

        .next-boss-name {
          font-size: clamp(16px, 6vw, 22px);
        }

        .next-boss-time {
          font-size: clamp(11px, 3.5vw, 14px);
        }
      }

      .right-column {
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-height: 0;
      }

      #bossListPanel,
      #timersPanel {
        min-height: 0;
      }
    </style>
  </head>
  <body>
    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading...</div>
    </div>

    <div class="container">
      <header class="app-header">
        <div class="app-title">
          <div class="logo">
            <img
              class="logo-img"
              src="https://raw.githubusercontent.com/momowzen/DFck.LordnineSpawnTracker/refs/heads/main/assets/images/logo5.png"
              alt="Logo"
            />
          </div>
          <div class="app-title-text">
            <div class="main-title">Spawn Time Tracker</div>
            <div class="warning-text">for Ricardo01</div>
          </div>
        </div>
        <div class="header-controls">
          <div class="search-wrapper">
            <input
              type="text"
              class="search"
              id="searchBox"
              placeholder="Search boss name..."
            />
            <button class="search-clear" id="searchClear">
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
          <button class="settings" id="settingsBtn">
            <span class="line"></span>
            <span class="line"></span>
            <span class="line"></span>
          </button>
        </div>
      </header>

      <div class="main">
        <div id="bossListPanel" class="card">
          <div class="card-header">Boss List</div>
          <div class="card-body" id="bossList"></div>
        </div>

        <div class="right-column">
          <div id="nextBoss" class="card">
            <div class="next-boss-name" id="nextBossName">‚Äî</div>
            <div class="next-boss-time" id="nextTime">‚Äî</div>
          </div>

          <div id="timersPanel" class="card">
            <div class="card-header">
              <span>Active Timers</span>
              <button class="sort-btn" id="sortBtn">Sort: Time</button>
            </div>
            <div class="card-body" id="timers"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-backdrop" id="settingsModalBackdrop">
      <div class="modal">
        <div class="modal-header">Settings</div>
        <div class="modal-body">
          <div class="modal-section">
            <h3>Synchronization</h3>
            <div class="modal-actions">
              <button class="kbtn" id="syncBtn">Sync All Users</button>
            </div>
          </div>

          <div class="modal-section">
            <h3>Data Management</h3>
            <div class="modal-actions">
              <button class="kbtn" id="exportBtn">Export</button>
              <button class="kbtn" id="importBtn">Import</button>
              <button class="kbtn" id="resetBtn">Reset All</button>
            </div>
          </div>

          <div class="modal-section">
            <h3>Discord Webhook</h3>
            <input
              type="text"
              class="modal-input"
              id="webhookInput"
              placeholder="Paste webhook URL..."
            />
            <div class="modal-actions">
              <button class="kbtn" id="webhookSave">Save</button>
              <button class="kbtn" id="webhookTest">Test</button>
              <button class="kbtn" id="webhookClear">Clear</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-backdrop" id="timeModalBackdrop">
      <div class="modal">
        <div class="modal-header" id="timeModalTitle">Set Spawn Time</div>
        <div class="modal-body">
          <div class="modal-section">
            <label class="time-picker-label">Select spawn date and time:</label>
            <input
              type="datetime-local"
              class="datetime-input"
              id="datetimeInput"
            />
          </div>
          <div class="modal-actions">
            <button class="kbtn" id="saveTimeBtn">Save</button>
            <button class="kbtn" id="cancelTimeBtn">Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <div id="chatBox" class="chat-box">
      <div class="chat-header">
        Chat
        <button id="chatMinimize" class="chat-minimize-btn">‚àí</button>
      </div>
      <div id="chatMessages" class="chat-messages"></div>
      <div class="chat-input-area">
        <input id="chatInput" type="text" placeholder="Type a message..." />
        <button id="chatSend">Send</button>
      </div>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        onSnapshot,
        updateDoc,
        deleteField,
        runTransaction,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
      import {
        getDatabase,
        ref,
        set,
        push,
        onValue,
        onDisconnect,
        serverTimestamp as rtdbServerTimestamp,
        get,
        onChildAdded,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyD9n0a6rQbt_M3J51pIILf-Ticjbttc3eg",
        authDomain: "lordnine-timer-9f21e.firebaseapp.com",
        databaseURL:
          "https://lordnine-timer-9f21e-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "lordnine-timer-9f21e",
        storageBucket: "lordnine-timer-9f21e.firebasestorage.app",
        messagingSenderId: "644000692891",
        appId: "1:644000692891:web:224bca1478655a43c0243e",
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const rtdb = getDatabase(app);

      const BOSSES = [
        { id: "Venatus", name: "Venatus", respawn: 60 * 60 * 10 },
        { id: "Viorent", name: "Viorent", respawn: 60 * 60 * 10 },
        { id: "Ego", name: "Ego", respawn: 60 * 60 * 21 },
        {
          id: "Clemantis",
          name: "Clemantis",
          weeklyRespawns: [
            { day: 1, hour: 12, minute: 30 },
            { day: 4, hour: 20, minute: 0 },
          ],
        },
        { id: "Livera", name: "Livera", respawn: 60 * 60 * 24 },
        { id: "Araneo", name: "Araneo", respawn: 60 * 60 * 24 },
        { id: "Undomiel", name: "Undomiel", respawn: 60 * 60 * 24 },
        {
          id: "Saphirus",
          name: "Saphirus",
          weeklyRespawns: [
            { day: 0, hour: 18, minute: 0 },
            { day: 2, hour: 12, minute: 30 },
          ],
        },
        {
          id: "Neutro",
          name: "Neutro",
          weeklyRespawns: [
            { day: 2, hour: 20, minute: 0 },
            { day: 4, hour: 12, minute: 30 },
          ],
        },
        { id: "LadyDalia", name: "Lady Dalia", respawn: 60 * 60 * 18 },
        {
          id: "GeneralAquleus",
          name: "General Aquleus",
          respawn: 60 * 60 * 29,
        },
        {
          id: "Thymele",
          name: "Thymele",
          weeklyRespawns: [
            { day: 1, hour: 20, minute: 0 },
            { day: 3, hour: 12, minute: 30 },
          ],
        },
        { id: "Amentis", name: "Amentis", respawn: 60 * 60 * 29 },
        {
          id: "BaronBraudmore",
          name: "Baron Braudmore",
          respawn: 60 * 60 * 32,
        },
        {
          id: "Milavy",
          name: "Milavy",
          weeklyRespawns: [{ day: 6, hour: 16, minute: 0 }],
        },
        { id: "Wannitas", name: "Wannitas", respawn: 60 * 60 * 48 },
        { id: "Metus", name: "Metus", respawn: 60 * 60 * 48 },
        { id: "Duplican", name: "Duplican", respawn: 60 * 60 * 48 },
        { id: "Shuliar", name: "Shuliar", respawn: 60 * 60 * 35 },
        {
          id: "Ringor",
          name: "Ringor",
          weeklyRespawns: [{ day: 6, hour: 18, minute: 0 }],
        },
        {
          id: "Roderick",
          name: "Roderick",
          weeklyRespawns: [{ day: 5, hour: 20, minute: 0 }],
        },
        { id: "Gareth", name: "Gareth", respawn: 60 * 60 * 32 },
        { id: "Titore", name: "Titore", respawn: 60 * 60 * 37 },
        { id: "Larba", name: "Larba", respawn: 60 * 60 * 35 },
        { id: "Catena", name: "Catena", respawn: 60 * 60 * 35 },
        {
          id: "Auraq",
          name: "Auraq",
          weeklyRespawns: [
            { day: 5, hour: 23, minute: 0 },
            { day: 3, hour: 22, minute: 0 },
          ],
        },
        { id: "Secreta", name: "Secreta", respawn: 60 * 60 * 62 },
        { id: "Ordo", name: "Ordo", respawn: 60 * 60 * 62 },
        { id: "Asta", name: "Asta", respawn: 60 * 60 * 62 },
        { id: "Supore", name: "Supore", respawn: 60 * 60 * 62 },
        {
          id: "Chaiflock",
          name: "Chaiflock",
          weeklyRespawns: [{ day: 6, hour: 23, minute: 0 }],
        },
        {
          id: "Benji",
          name: "Benji",
          weeklyRespawns: [{ day: 0, hour: 22, minute: 0 }],
        }
      ];

      let timers = {};
      let deadLocks = {};
      let firebaseLoaded = false;
      let cachedWebhookUrl = "";
      let currentBossForTime = null;
      let sortMode = "time"; // "time" or "name"

      const loadingOverlay = document.getElementById("loadingOverlay");
      const bossListEl = document.getElementById("bossList");
      const timersEl = document.getElementById("timers");
      const nextBossNameEl = document.getElementById("nextBossName");
      const nextTimeEl = document.getElementById("nextTime");
      const searchBox = document.getElementById("searchBox");
      const searchClear = document.getElementById("searchClear");
      const settingsBtn = document.getElementById("settingsBtn");
      const settingsModalBackdrop = document.getElementById(
        "settingsModalBackdrop"
      );
      const exportBtn = document.getElementById("exportBtn");
      const importBtn = document.getElementById("importBtn");
      const resetBtn = document.getElementById("resetBtn");
      const webhookInput = document.getElementById("webhookInput");
      const webhookSave = document.getElementById("webhookSave");
      const webhookTest = document.getElementById("webhookTest");
      const webhookClear = document.getElementById("webhookClear");
      const timeModalBackdrop = document.getElementById("timeModalBackdrop");
      const timeModalTitle = document.getElementById("timeModalTitle");
      const datetimeInput = document.getElementById("datetimeInput");
      const saveTimeBtn = document.getElementById("saveTimeBtn");
      const cancelTimeBtn = document.getElementById("cancelTimeBtn");
      const sortBtn = document.getElementById("sortBtn");
      const syncBtn = document.getElementById("syncBtn");
      const timersPanelEl = document.getElementById("timersPanel");
      const timersPanelHeader = timersPanelEl?.querySelector(".card-header");

      // Mobile timers panel toggle
      if (timersPanelHeader && window.innerWidth <= 768) {
        timersPanelHeader.addEventListener("click", () => {
          timersPanelEl.classList.toggle("expanded");
        });
      }

      function formatTime(ms) {
        const totalSec = Math.floor(ms / 1000);
        const h = Math.floor(totalSec / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        const s = totalSec % 60;
        return `${h.toString().padStart(2, "0")}:${m
          .toString()
          .padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
      }

      function formatTimeWithDays(ms) {
        const totalSec = Math.floor(ms / 1000);
        const days = Math.floor(totalSec / 86400);
        const h = Math.floor((totalSec % 86400) / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        const s = totalSec % 60;

        if (days > 0) {
          return `${days}d ${h.toString().padStart(2, "0")}:${m
            .toString()
            .padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
        }
        return `${h.toString().padStart(2, "0")}:${m
          .toString()
          .padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
      }

      function formatDateTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString("en-US", {
          month: "short",
          day: "numeric",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit",
        });
      }

      function getNextWeeklyRespawn(schedule, afterMs) {
        const after = new Date(afterMs);
        const candidates = [];
        for (let offset = 0; offset < 14; offset++) {
          for (const slot of schedule) {
            const candidate = new Date(after);
            candidate.setDate(after.getDate() + offset);
            const dow = candidate.getDay();
            const targetDow = slot.day % 7;
            if (dow !== targetDow) continue;
            candidate.setHours(slot.hour, slot.minute, 0, 0);
            if (candidate.getTime() > afterMs)
              candidates.push(candidate.getTime());
          }
        }
        return candidates.length ? Math.min(...candidates) : afterMs + 86400000;
      }

      async function saveTimers() {
        if (!firebaseLoaded) return;
        try {
          const docRef = doc(db, "timers", "global");
          await setDoc(docRef, { timers }, { merge: true });
        } catch (e) {
          console.error("Save error:", e);
        }
      }

      async function saveWebhookToFirestore(url) {
        try {
          await setDoc(doc(db, "config", "discordWebhook"), { url });
          cachedWebhookUrl = url;
          webhookInput.value = url;
          alert("‚úÖ Webhook saved");
          console.log("‚úÖ Webhook saved to Firestore.");
        } catch (e) {
          console.warn("save webhook err", e);
          alert("‚ùå Failed to save webhook");
        }
      }

      async function loadWebhookFromFirestore() {
        try {
          const docRef = doc(db, "config", "discordWebhook");
          const snap = await getDoc(docRef);
          if (snap.exists()) {
            const data = snap.data();
            cachedWebhookUrl = data.url || null;
            webhookInput.value = cachedWebhookUrl || "";
            console.log("‚úÖ Loaded webhook from Firestore.");
            return cachedWebhookUrl;
          } else {
            cachedWebhookUrl = null;
            webhookInput.value = "";
            console.log("‚Ñπ No webhook stored in Firestore.");
            return null;
          }
        } catch (e) {
          console.warn("load webhook err", e);
          return null;
        }
      }

      async function clearWebhookInFirestore() {
        try {
          await setDoc(doc(db, "config", "discordWebhook"), { url: "" });
          cachedWebhookUrl = null;
          webhookInput.value = "";
          alert("‚úÖ Webhook cleared");
          console.log("‚úÖ Webhook cleared from Firestore.");
        } catch (e) {
          console.warn("clear webhook err", e);
          alert("‚ùå Failed to clear webhook");
        }
      }

      async function testWebhook() {
        if (!cachedWebhookUrl && !webhookInput.value.trim()) {
          alert("No webhook URL configured.");
          return;
        }
        if (!cachedWebhookUrl) cachedWebhookUrl = webhookInput.value.trim();

        const testBoss = BOSSES[0] || null;
        await sendDiscordEmbed(
          buildEmbed(
            "üß™ Webhook test successful!",
            "This is a test message from Lordnine Tracker.",
            0x00ff99,
            testBoss
          )
        );
        alert("Test sent (check your Discord).");
      }

      async function autoLoadWebhook() {
        try {
          const docRef = doc(db, "config", "discordWebhook");
          const snap = await getDoc(docRef);
          if (snap.exists()) {
            const data = snap.data();
            cachedWebhookUrl = data.url || null;
            console.log("‚úÖ Webhook loaded on startup:", cachedWebhookUrl);
          } else {
            console.warn("‚ö†Ô∏è No webhook found in Firestore config.");
          }
        } catch (e) {
          console.error("‚ùå Failed to auto-load webhook:", e);
        }
      }

      function buildEmbed(title, description, colorHex, boss) {
        const embed = {
          title,
          description,
          color: colorHex,
          footer: { text: "Lordnine Tracker" },
          timestamp: new Date().toISOString(),
        };

        // Add boss image if boss object is provided
        if (boss && boss.id) {
          embed.thumbnail = {
            url: `https://raw.githubusercontent.com/momowzen/DFck.LordnineSpawnTracker/refs/heads/main/assets/images/${boss.id}.png`,
            height: 300,
            width: 300,
          };
        }

        return embed;
      }

      async function sendDiscordEmbed(embed) {
        if (!cachedWebhookUrl) {
          console.warn("‚ö†Ô∏è No Discord webhook configured.");
          return;
        }

        try {
          const payload = {
            content: "",
            embeds: [embed],
          };

          const res = await fetch(cachedWebhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (!res.ok) {
            console.error(
              "‚ùå Discord webhook failed:",
              res.status,
              await res.text()
            );
          } else {
            console.log("‚úÖ Discord embed sent successfully.");
          }
        } catch (err) {
          console.error("‚ö†Ô∏è Discord webhook error:", err);
        }
      }

      async function sendDiscordNotification(message) {
        if (!cachedWebhookUrl) return;
        try {
          await fetch(cachedWebhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ content: message }),
          });
        } catch (e) {
          console.error("Discord notification error:", e);
        }
      }

      let localNotifCache = {}; // Local dedupe cache for Discord notifications

      // Deduplicated Discord embed send with Firestore server-side tracking
      async function sendDiscordEmbedOnce(type, boss) {
        try {
          if (!boss || !type) return;

          const safeId = encodeURIComponent(boss.id.trim());
          const key = `${safeId}_${type}`;

          const now = Date.now();
          const localWindow = 2 * 60 * 1000; // 2 min client dedupe

          // Local dedupe guard (fast path)
          if (
            localNotifCache[key] &&
            now - localNotifCache[key] < localWindow
          ) {
            console.log(
              `üõë Locally skipped duplicate ${type} notification for ${boss.name}`
            );
            return;
          }

          // Reserve locally
          localNotifCache[key] = now;
          console.log(`üîí Local reserve set for ${key}`);

          const ref = doc(db, "notifications", key);
          const thresholdMs = 2 * 60 * 1000; // server dedupe window

          const txResult = await runTransaction(db, async (tx) => {
            const snap = await tx.get(ref);
            const data = snap.exists() ? snap.data() : {};

            // Normalize timestamp formats
            let lastSentMs = 0;
            if (data.lastSent && typeof data.lastSent.toMillis === "function") {
              lastSentMs = data.lastSent.toMillis();
            } else if (typeof data.lastSent === "number") {
              lastSentMs = data.lastSent;
            } else if (typeof data.lastSent === "string") {
              const parsed = Date.parse(data.lastSent);
              if (!isNaN(parsed)) lastSentMs = parsed;
            }

            const lastEndTimeMs = data.lastEndTimeMs || 0;
            const thisEndTimeMs = timers[boss.id]?.endTime || 0;
            const nowMs = Date.now();

            // Only skip if (a) last send < 2min ago AND (b) same spawn cycle
            const recentlySent =
              nowMs - lastSentMs < thresholdMs &&
              lastEndTimeMs === thisEndTimeMs;

            if (recentlySent) {
              console.log(
                `‚è∏Ô∏è Firestore dedupe prevented ${type} for ${boss.name} (same spawn cycle)`
              );
              return false;
            }

            // Write both lastSent + lastEndTimeMs atomically
            tx.set(
              ref,
              {
                lastSent: serverTimestamp(),
                lastEndTimeMs: thisEndTimeMs,
                bossId: boss.id,
                type,
              },
              { merge: true }
            );

            return { endTimeMs: thisEndTimeMs };
          });

          if (!txResult) {
            console.log(
              `‚èπÔ∏è sendDiscordEmbedOnce: server dedupe prevented sending ${type} for ${boss.name}`
            );
            return;
          }

          const spawnUnix = Math.floor((txResult.endTimeMs || timers[boss.id]?.endTime || Date.now()) / 1000);

          // Build appropriate embed
          let embed;
          switch (type) {
            case "killed":
              embed = buildEmbed(
                `üíÄ ${boss.name} has been defeated!`,
                `Next respawn:\n<t:${spawnUnix}:f>`,
                0xff3333,
                boss
              );
              break;

            case "soon":
              embed = buildEmbed(
                `‚ö†Ô∏è ${boss.name} will respawn soon!`,
                `Spawn expected in 5 minutes.\nSpawn time:\n<t:${spawnUnix}:f>`,
                0xffcc00,
                boss
              );
              break;

            case "spawn":
              embed = buildEmbed(
                `‚öîÔ∏è ${boss.name} has spawned!`,
                `It's time to hunt!`,
                0xb266ff,
                boss
              );
              break;

            case "manual":
              embed = buildEmbed(
                `‚è∞ ${boss.name} manual time set.`,
                `Next respawn:\n<t:${spawnUnix}:f>`,
                0x3399ff,
                boss
              );
              break;

            default:
              console.warn(`‚ö†Ô∏è Unknown notification type: ${type}`);
              return;
          }

          // Final Discord send
          await sendDiscordEmbed(embed);
          console.log(`‚úÖ Sent ${type} notification for ${boss.name}`);
        } catch (e) {
          if (e?.code === "ABORTED") {
            console.warn("‚ÑπÔ∏è Transaction aborted (expected):", e);
            return;
          }
          console.warn("‚ö†Ô∏è sendDiscordEmbedOnce error:", e);
          const safeId = encodeURIComponent(boss.id.trim());
          delete localNotifCache[`${safeId}_${type}`]; // allow retry if failed
        }
      }

      async function markDead(id) {
        const boss = BOSSES.find((b) => b.id === id);
        if (!boss) return;

        const now = Date.now();
        let endTime;

        if (boss.weeklyRespawns) {
          endTime = getNextWeeklyRespawn(boss.weeklyRespawns, now + 1);
        } else if (boss.respawn) {
          endTime = now + boss.respawn * 1000;
        }

        timers[id] = {
          endTime,
          startedAt: now,
          notifiedSoon: false,
          spawnAnnounced: false,
          cooldownUntil: now + 5000,
          weekly: !!boss.weeklyRespawns,
        };

        saveTimers();
        rebuildTimersPanel();
        renderBossList();
        computeNextBoss();

        setDoc(
          doc(db, "meta", "deadLocks"),
          { [id]: now + 5000 },
          { merge: true }
        );

        // Send Discord embed notification (deduplicated)
        await sendDiscordEmbedOnce("killed", boss);
      }

      function openTimeModal(id) {
        const boss = BOSSES.find((b) => b.id === id);
        if (!boss) return;

        currentBossForTime = id;
        timeModalTitle.textContent = `Set Time: ${boss.name}`;

        // Set default to current time
        const now = new Date();
        const offset = now.getTimezoneOffset() * 60000;
        const localISOTime = new Date(now - offset).toISOString().slice(0, 16);
        datetimeInput.value = localISOTime;

        timeModalBackdrop.style.display = "flex";
      }

      async function cancelTimer(id) {
        try {
          // Delete directly from Firebase using updateDoc with field deletion
          const docRef = doc(db, "timers", "global");
          const updateData = {};
          updateData[`timers.${id}`] = deleteField();
          await updateDoc(docRef, updateData);

          // Remove from local state
          delete timers[id];
          rebuildTimersPanel();
          renderBossList();
          computeNextBoss();
        } catch (e) {
          console.error("Failed to delete timer from Firebase:", e);
          alert("‚ùå Failed to delete timer");
        }
      }

      function resetAll() {
        timers = {};
        saveTimers();
        rebuildTimersPanel();
        renderBossList();
        computeNextBoss();
      }

      function renderBossList() {
        const query = searchBox.value.toLowerCase();
        bossListEl.innerHTML = "";

        BOSSES.filter((b) => b.name.toLowerCase().includes(query)).forEach(
          (boss) => {
            const hasTimer = timers[boss.id];
            const isWeekly = !!boss.weeklyRespawns;
            const div = document.createElement("div");
            div.className = "boss";

            let subText = "";
            if (boss.weeklyRespawns) {
              subText = boss.weeklyRespawns
                .map(
                  (r) =>
                    ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][r.day] +
                    " " +
                    String(r.hour).padStart(2, "0") +
                    ":" +
                    String(r.minute).padStart(2, "0")
                )
                .join(", ");
            } else if (boss.respawn) {
              subText = `${boss.respawn / 3600} hr`;
            }

            const imageUrl = `https://raw.githubusercontent.com/momowzen/DFck.LordnineSpawnTracker/refs/heads/main/assets/images/${boss.id}.png`;

            let buttons = "";
            if (isWeekly) {
              // Weekly boss: only Killed button
              buttons = `
              <button class="kbtn" data-action="mark" data-id="${boss.id}">
                <svg class="kbtn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"></path>
                </svg>
                <span class="kbtn-text">Killed</span>
              </button>`;
            } else {
              // Non-weekly boss: Killed, Set buttons, and Cancel only if timer exists
              buttons = `
              <button class="kbtn" data-action="mark" data-id="${boss.id}">
                <svg class="kbtn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"></path>
                </svg>
                <span class="kbtn-text">Killed</span>
              </button>`;
              buttons += `
              <button class="kbtn" data-action="set" data-id="${boss.id}">
                <svg class="kbtn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <polyline points="12 6 12 12 16 14"></polyline>
                </svg>
                <span class="kbtn-text">Set</span>
              </button>`;
              if (hasTimer) {
                buttons += `
                <button class="kbtn" data-action="cancel" data-id="${boss.id}">
                  <svg class="kbtn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                  <span class="kbtn-text">Cancel</span>
                </button>`;
              }
            }

            div.innerHTML = `
            <div class="boss-background" style="background-image: url('${imageUrl}');"></div>
            <div class="boss-overlay"></div>
            <div class="boss-content">
              <div class="boss-info">
                <div class="name">${boss.name}</div>
                <div class="sub">${subText}</div>
              </div>
              <div class="boss-actions">
                ${buttons}
              </div>
            </div>
          `;

            div.querySelectorAll(".kbtn").forEach((btn) => {
              const action = btn.getAttribute("data-action");
              const id = btn.getAttribute("data-id");
              if (action === "mark") {
                btn.addEventListener("click", () => markDead(id));
              } else if (action === "set") {
                btn.addEventListener("click", () => openTimeModal(id));
              } else if (action === "cancel") {
                btn.addEventListener("click", () => cancelTimer(id));
              }
            });

            bossListEl.appendChild(div);
          }
        );
      }

      function updateTimerRemaining(timerElement) {
        const remainingEl = timerElement.querySelector(".timer-remaining");
        if (!remainingEl) return;

        const endTime = parseInt(timerElement.getAttribute("data-end-time"));
        const remaining = Math.max(0, endTime - Date.now());
        remainingEl.textContent = `Remaining: ${formatTimeWithDays(remaining)}`;
      }

      function rebuildTimersPanel() {
        timersEl.innerHTML = "";
        const now = Date.now();

        let timerArray = Object.keys(timers)
          .map((id) => {
            const boss = BOSSES.find((b) => b.id === id);
            const info = timers[id];
            return { id, boss, info };
          })
          .filter((t) => t.boss);

        // Sort
        if (sortMode === "time") {
          timerArray.sort((a, b) => {
            const timeA = a.info.cooldownUntil || a.info.endTime;
            const timeB = b.info.cooldownUntil || b.info.endTime;
            return timeA - timeB;
          });
        } else {
          timerArray.sort((a, b) => a.boss.name.localeCompare(b.boss.name));
        }

        timerArray.forEach(({ id, boss, info }) => {
          const remaining = Math.max(0, info.endTime - now);
          const isReady = remaining === 0;
          const isCooldown = info.cooldownUntil && now < info.cooldownUntil;

          const div = document.createElement("div");
          div.className = "timer" + (isReady ? " ready" : "");
          div.setAttribute("data-id", id);
          div.setAttribute("data-end-time", info.endTime);

          div.innerHTML = `
            <div class="timer-header">
              <div class="timer-name">${boss.name}</div>
            </div>
            <div class="timer-spawn">Spawns: ${formatDateTime(
              info.endTime
            )}</div>
            <div class="timer-remaining">Remaining: ${formatTimeWithDays(remaining)}</div>
          `;

          // Add hover listeners for live countdown
          div.addEventListener("mouseenter", () => {
            updateTimerRemaining(div);
            div.timerInterval = setInterval(() => updateTimerRemaining(div), 1000);
          });

          div.addEventListener("mouseleave", () => {
            if (div.timerInterval) clearInterval(div.timerInterval);
          });

          timersEl.appendChild(div);
        });

        if (timersEl.children.length === 0) {
          timersEl.innerHTML =
            '<div style="text-align: center; color: var(--text-dim); padding: 20px;">No active timers</div>';
        }
      }

      let nextBoss = null;
      let nextBossTime = Infinity;
      let nextBossIsCooldown = false;

      function computeNextBoss() {
        const now = Date.now();
        nextBoss = null;
        nextBossTime = Infinity;
        nextBossIsCooldown = false;

        Object.keys(timers).forEach((id) => {
          const info = timers[id];

          // Determine the target end time (cooldown or regular timer)
          const targetTime = info.cooldownUntil || info.endTime;

          // Find the soonest ending timer (including cooldowns)
          if (targetTime < nextBossTime && targetTime > now) {
            nextBossTime = targetTime;
            nextBoss = BOSSES.find((b) => b.id === id);
            nextBossIsCooldown = !!info.cooldownUntil; // Mark if it's a cooldown
          }
        });

        if (nextBoss) {
          nextBossNameEl.textContent = nextBoss.name;
          updateNextBossTime();
        } else {
          nextBossNameEl.textContent = "No active timers";
          nextTimeEl.textContent = "";
        }
      }

      function updateNextBossTime() {
        if (!nextBoss || nextBossTime === Infinity) return;
        const remaining = Math.max(0, nextBossTime - Date.now());
        nextTimeEl.textContent = nextBossIsCooldown
          ? "SPAWNED"
          : formatTimeWithDays(remaining);
      }

      async function tickUpdate() {
        const now = Date.now();
        let hasChanges = false;

        for (const [id, info] of Object.entries(timers)) {
          const boss = BOSSES.find((b) => b.id === id);
          if (!boss) continue;

          // Determine current phase (active timer vs cooldown)
          const activeEndTime = info.cooldownUntil || info.endTime;
          const remainingMs = activeEndTime - now;

          const bossCard = document.querySelector(`.boss[data-id="${id}"]`);
          const nameElem = bossCard?.querySelector(".name");

          // (0) Handle cooldown visuals & skip logic during cooldown
          if (info.cooldownUntil && now < info.cooldownUntil) {
            // Ensure boss name shows alive look (no .dead)
            if (nameElem && nameElem.classList.contains("dead")) {
              nameElem.classList.remove("dead");
            }
            continue; // Skip further processing while cooldown active
          }

          // (1) Apply .dead automatically when timer is running
          if (remainingMs > 0 && !info.cooldownUntil) {
            if (nameElem && !nameElem.classList.contains("dead")) {
              nameElem.classList.add("dead");
            }
          }

          // (2) Soon warning (5 minutes before spawn)
          if (
            remainingMs <= 5 * 60 * 1000 &&
            remainingMs > 0 &&
            !info.notifiedSoon &&
            !info.cooldownUntil
          ) {
            info.notifiedSoon = true;
            await sendDiscordEmbedOnce("soon", boss);
          }

          // (3) Spawn announcement when timer reaches 0
          if (remainingMs <= 0 && !info.spawnAnnounced && !info.cooldownUntil) {
            info.spawnAnnounced = true;
            await sendDiscordEmbedOnce("spawn", boss);
          }

          // (4) Start 3-minute cooldown when reaching 0
          if (remainingMs <= 0 && !info.cooldownUntil) {
            info.cooldownUntil = now + 3 * 60 * 1000;
            hasChanges = true;
            console.log(
              `‚è≥ ${boss.name} entering 3-minute cooldown until ${new Date(
                info.cooldownUntil
              ).toLocaleTimeString()}`
            );

            // Visual: back to normal appearance during cooldown
            if (nameElem) nameElem.classList.remove("dead");

            // Save cooldown state
            await saveTimers();
            continue;
          }

          // (5) Cooldown ended ‚Äì restart timer automatically
          if (info.cooldownUntil && now >= info.cooldownUntil) {
            console.log(`‚úÖ ${boss.name} cooldown ended ‚Äì restarting cycle...`);
            hasChanges = true;

            const nowLater = Date.now();
            let nextTime;

            if (boss.weeklyRespawns) {
              nextTime = getNextWeeklyRespawn(
                boss.weeklyRespawns,
                nowLater + 1
              );
              while (nextTime <= nowLater) nextTime += 7 * 24 * 60 * 60 * 1000;
            } else {
              nextTime = nowLater + boss.respawn * 1000;
            }

            // Reset timer and clear cooldown
            timers[id] = {
              endTime: nextTime,
              startedAt: nowLater,
              weekly: !!boss.weeklyRespawns,
              notifiedSoon: false,
              spawnAnnounced: false,
              cooldownUntil: null,
            };

            // Apply .dead class again (timer active)
            if (nameElem && !nameElem.classList.contains("dead")) {
              nameElem.classList.add("dead");
            }

            await saveTimers();
            rebuildTimersPanel();
            renderBossList();

            console.log(`üîÅ ${boss.name} timer restarted after cooldown.`);
            continue;
          }
        }

        // Only update UI if there were actual state changes
        if (hasChanges) {
          computeNextBoss();
          rebuildTimersPanel();
        }
      }

      // Run tickUpdate every 1 second
      setInterval(() => tickUpdate(), 1000);

      // Update next boss countdown every 100ms for smooth display without flickering
      setInterval(() => updateNextBossTime(), 100);

      // Search functionality
      function updateSearchClearButton() {
        if (searchBox.value.trim()) {
          searchClear.classList.add("visible");
        } else {
          searchClear.classList.remove("visible");
        }
      }

      searchBox.addEventListener("input", () => {
        renderBossList();
        updateSearchClearButton();
      });

      searchClear.addEventListener("click", () => {
        searchBox.value = "";
        renderBossList();
        updateSearchClearButton();
        searchBox.focus();
      });

      sortBtn.addEventListener("click", () => {
        sortMode = sortMode === "time" ? "name" : "time";
        sortBtn.textContent = `Sort: ${sortMode === "time" ? "Time" : "Name"}`;
        rebuildTimersPanel();
      });

      settingsBtn.addEventListener("click", async () => {
        await loadWebhookFromFirestore();
        settingsModalBackdrop.style.display = "flex";
      });

      settingsModalBackdrop.addEventListener("click", (e) => {
        if (e.target === settingsModalBackdrop) {
          settingsModalBackdrop.style.display = "none";
        }
      });

      timeModalBackdrop.addEventListener("click", (e) => {
        if (e.target === timeModalBackdrop) {
          timeModalBackdrop.style.display = "none";
        }
      });

      saveTimeBtn.addEventListener("click", async () => {
        if (!currentBossForTime || !datetimeInput.value) return;

        const boss = BOSSES.find((b) => b.id === currentBossForTime);
        if (!boss) return;

        const selectedTime = new Date(datetimeInput.value).getTime();
        const now = Date.now();

        timers[currentBossForTime] = {
          endTime: selectedTime,
          startedAt: now,
          notifiedSoon: false,
          spawnAnnounced: false,
          cooldownUntil: null,
          weekly: false,
        };

        saveTimers();
        rebuildTimersPanel();
        renderBossList();
        computeNextBoss();
        timeModalBackdrop.style.display = "none";

        setDoc(
          doc(db, "meta", "deadLocks"),
          { [currentBossForTime]: now + 5000 },
          { merge: true }
        );

        // Send Discord embed notification (deduplicated)
        await sendDiscordEmbedOnce("manual", boss);
      });

      cancelTimeBtn.addEventListener("click", () => {
        timeModalBackdrop.style.display = "none";
      });

      exportBtn.addEventListener("click", () => {
        try {
          const blob = new Blob([JSON.stringify(timers, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "boss_timers_backup.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          alert("‚úÖ Timers exported successfully");
        } catch (e) {
          alert("‚ùå Failed to export timers");
        }
      });

      importBtn.addEventListener("click", () => {
        settingsModalBackdrop.style.display = "none";
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.onchange = async (event) => {
          const file = event.target.files[0];
          if (!file) return;
          const text = await file.text();
          try {
            const imported = JSON.parse(text);
            if (
              confirm(
                "Import this JSON data? It will overwrite existing timers."
              )
            ) {
              timers = imported;
              await saveTimers();
              rebuildTimersPanel();
              renderBossList();
              alert("‚úÖ Timers imported successfully");
            }
          } catch (e) {
            alert("‚ùå Invalid JSON file");
          }
        };
        input.click();
      });

      resetBtn.addEventListener("click", () => {
        settingsModalBackdrop.style.display = "none";
        if (confirm("Are you sure you want to reset all timers?")) resetAll();
      });

      const deadLockRef = doc(db, "meta", "deadLocks");
      onSnapshot(deadLockRef, (snapshot) => {
        const data = snapshot.data() || {};
        deadLocks = data;
        const now = Date.now();

        document
          .querySelectorAll('.kbtn[data-action="mark"]')
          .forEach((btn) => {
            const bossId = btn.getAttribute("data-id");
            const lockedUntil = deadLocks[bossId] || 0;
            btn.disabled = now < lockedUntil;
          });
      });

      setInterval(() => {
        const now = Date.now();
        document
          .querySelectorAll('.kbtn[data-action="mark"]')
          .forEach((btn) => {
            const bossId = btn.getAttribute("data-id");
            const lockedUntil = deadLocks[bossId] || 0;
            btn.disabled = now < lockedUntil;
          });
      }, 10000);

      webhookSave.addEventListener("click", async () => {
        const url = webhookInput.value.trim();
        if (!url) {
          alert("Please paste a webhook URL");
          return;
        }
        await saveWebhookToFirestore(url);
      });

      webhookTest.addEventListener("click", async () => {
        if (!cachedWebhookUrl) await loadWebhookFromFirestore();
        await testWebhook();
      });

      webhookClear.addEventListener("click", async () => {
        if (!confirm("Clear webhook from Firestore?")) return;
        await clearWebhookInFirestore();
      });

      // Sync functionality
      let lastTriggeredBySelf = null;
      const refreshDocRef = doc(db, "meta", "refresh");

      syncBtn.addEventListener("click", async () => {
        settingsModalBackdrop.style.display = "none";
        if (
          confirm(
            "Synchronize all clients? This will reload every user's page."
          )
        ) {
          const now = Date.now();
          lastTriggeredBySelf = now;
          await setDoc(refreshDocRef, { forceRefresh: now });
          alert("‚úÖ Synchronization triggered for all connected users.");
          console.log("üîÅ Sync triggered at", new Date(now).toISOString());
        }
      });

      // Auto-refresh on Firestore update
      let hasInitialized = false;
      onSnapshot(refreshDocRef, (snapshot) => {
        const data = snapshot.data();
        if (!data) return;
        const lastTrigger = data.forceRefresh;
        const lastTriggerMs =
          lastTrigger && lastTrigger.toMillis
            ? lastTrigger.toMillis()
            : lastTrigger;

        if (!hasInitialized) {
          hasInitialized = true;
          return;
        }
        if (lastTriggerMs === lastTriggeredBySelf) return;

        console.log("üîÑ Firestore refresh triggered, reloading page.");
        location.reload();
      });

      async function init() {
        loadingOverlay.style.display = "flex";

        await new Promise((resolve) => {
          if (
            document.readyState === "complete" ||
            document.readyState === "interactive"
          )
            resolve();
          else
            document.addEventListener("DOMContentLoaded", resolve, {
              once: true,
            });
        });

        bossListEl.innerHTML = "";
        timersEl.innerHTML = "";
        nextBossNameEl.textContent = "";
        nextTimeEl.textContent = "";

        try {
          const docRef = doc(db, "timers", "global");
          onSnapshot(docRef, async (snap) => {
            if (!snap.exists()) {
              await setDoc(docRef, { timers: {} }, { merge: true });
              return;
            }

            const remoteTimers = snap.data().timers || {};
            const now = Date.now();

            // Use Firebase as source of truth - just update local state from remote
            timers = remoteTimers;
            rebuildTimersPanel();
            renderBossList();
            computeNextBoss();
          });
        } catch (e) {
          console.warn("Firestore load failed", e);
        }

        const now = Date.now();
        let timersChanged = false;

        for (const [id, info] of Object.entries(timers)) {
          const boss = BOSSES.find((b) => b.id === id);
          if (!boss || !info || !info.endTime) continue;

          if (info.cooldownUntil && info.cooldownUntil > now) continue;

          if (info.endTime <= now) {
            if (boss.weeklyRespawns) {
              const next = getNextWeeklyRespawn(boss.weeklyRespawns, now + 1);
              timers[id] = {
                endTime: next,
                startedAt: now,
                weekly: true,
                notifiedSoon: false,
                spawnAnnounced: false,
                cooldownUntil: null,
              };
              timersChanged = true;
            } else if (boss.respawn) {
              const respMs = boss.respawn * 1000;
              const cycles = Math.floor((now - info.endTime) / respMs) + 1;
              const newEnd = info.endTime + cycles * respMs;
              timers[id] = {
                endTime: newEnd,
                startedAt: now,
                notifiedSoon: false,
                spawnAnnounced: false,
                cooldownUntil: null,
              };
              timersChanged = true;
            }
          }
        }

        if (timersChanged) {
          try {
            await saveTimers();
          } catch (err) {
            console.error("Failed to save normalized timers:", err);
          }
        }

        await autoLoadWebhook();

        firebaseLoaded = true;
        renderBossList();
        rebuildTimersPanel();
        computeNextBoss();
        loadingOverlay.style.display = "none";
      }

      window.addEventListener("load", () => init());

      const presenceRef = ref(rtdb, "presence");
      const myConnection = push(presenceRef);
      set(myConnection, { connected: true, timestamp: rtdbServerTimestamp() });
      onDisconnect(myConnection).remove();

      onValue(presenceRef, (snap) => {
        const count = snap.size || snap.numChildren();
        let el = document.getElementById("onlineCount");

        if (!el) {
          el = document.createElement("div");
          el.id = "onlineCount";
          el.classList.add("online-users");
          el.innerHTML = `<span class="count">${count}</span>`;
          document.body.appendChild(el);
        } else {
          const countSpan = el.querySelector(".count");
          if (countSpan && countSpan.textContent !== String(count)) {
            countSpan.textContent = count;
          }
        }
      });

      const chatBox = document.getElementById("chatBox");
      const chatMessages = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const chatSend = document.getElementById("chatSend");
      const chatMinimize = document.getElementById("chatMinimize");

      let lastSeenTimestamp = 0;
      let initialLoadComplete = false;

      function generateRandomUsername() {
        const prefixes = [
          "Dark",
          "Shadow",
          "Iron",
          "Neon",
          "Cyber",
          "Storm",
          "Phantom",
          "Eclipse",
        ];
        const boss = BOSSES[Math.floor(Math.random() * BOSSES.length)];
        const prefix =
          Math.random() < 0.8
            ? prefixes[Math.floor(Math.random() * prefixes.length)] + " "
            : "";
        return prefix + boss.name;
      }

      const localUserName = generateRandomUsername();

      function attachChatToggle() {
        const onlineUsers = document.getElementById("onlineCount");
        if (!onlineUsers) return setTimeout(attachChatToggle, 300);

        onlineUsers.style.cursor = "pointer";

        onlineUsers.addEventListener("click", () => {
          if (chatBox.classList.contains("hidden")) {
            chatBox.classList.remove("hidden");
            chatBox.classList.add("active");
            return;
          }

          chatBox.classList.toggle("active");

          if (chatBox.classList.contains("active")) {
            onlineUsers.classList.remove("notify");
            lastSeenTimestamp = Date.now();
          }
        });
      }
      attachChatToggle();

      if (chatMinimize) {
        chatMinimize.addEventListener("click", () => {
          chatBox.classList.add("hidden");
          chatBox.classList.remove("active");
        });
      }

      const chatRef = ref(rtdb, "globalChat");

      chatSend.addEventListener("click", sendMessage);
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") sendMessage();
      });

      function sendMessage() {
        const text = chatInput.value.trim();
        if (!text) return;

        push(chatRef, { name: localUserName, text, timestamp: Date.now() });
        chatInput.value = "";
        lastSeenTimestamp = Date.now();
      }

      function getUserColor(name) {
        if (name === localUserName) return "hsl(180, 80%, 70%)";
        let hash = 0;
        for (let i = 0; i < name.length; i++) {
          hash = name.charCodeAt(i) + ((hash << 5) - hash);
        }
        const hue = Math.abs(hash) % 360;
        return `hsl(${hue}, 70%, 70%)`;
      }

      get(chatRef).then((snapshot) => {
        if (snapshot.exists()) {
          let latest = 0;
          snapshot.forEach((child) => {
            const data = child.val();
            if (data.timestamp > latest) latest = data.timestamp;
          });
          lastSeenTimestamp = latest;
        }
        initialLoadComplete = true;
      });

      onChildAdded(chatRef, (snapshot) => {
        const data = snapshot.val();
        const msgEl = document.createElement("div");
        msgEl.className = "chat-message";

        const userColor = getUserColor(data.name);
        const time = new Date(data.timestamp).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });

        msgEl.innerHTML = `
					<strong style="
						color: ${userColor};
						text-shadow: 0 0 8px ${userColor};
					">${data.name}</strong>
					<small style="opacity: 0.7;">[${time}]</small>:
					<span style="
						color: ${userColor};
						text-shadow: 0 0 6px ${userColor};
					">${data.text}</span>
				`;

        chatMessages.appendChild(msgEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        if (!initialLoadComplete) return;
        if (data.timestamp <= lastSeenTimestamp) return;

        const onlineUsers = document.getElementById("onlineCount");
        if (onlineUsers && !chatBox.classList.contains("active")) {
          if (!onlineUsers.classList.contains("notify")) {
            onlineUsers.classList.add("notify");
            onlineUsers.animate(
              [
                { transform: "translateY(0)" },
                { transform: "translateY(-4px)" },
                { transform: "translateY(0)" },
              ],
              { duration: 300, easing: "ease-out" }
            );
          }
        }
      });

      setTimeout(() => {
        location.reload();
      }, 300000);
    </script>
  </body>
</html>
