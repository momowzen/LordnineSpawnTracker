<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width,initial-scale=1" name="viewport" />

  <title>LORDNINE TIME TRACKER</title>
  <link
    href="https://raw.githubusercontent.com/momowzen/DFck.LordnineSpawnTracker/refs/heads/main/assets/images/logo5.png"
    rel="icon" sizes="64x64" type="image/png" />
  <style>
    :root {
      --bg: #000000;
      --panel-bg: #0f0f0f;
      --muted: #9aa6b2;
      --accent: #00f0ff;
      --accent-2: #7dd3fc;
      --glass: rgba(255, 255, 255, 0.03);
      --radius: 10px;
      --shadow: 0 6px 20px rgba(0, 240, 255, 0.04);
      --glass-border: rgba(0, 240, 255, 0.08);
      --text: #dff7ff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
      font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      padding: 12px;
      max-width: 1200px;
      margin: 0 auto;
      gap: 12px;
    }

    /* === HEADER CONTAINER - DARK MINIMAL === */
    header.app-header {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      padding: 10px 16px;
      border-radius: 4px;
      box-shadow: none;
      backdrop-filter: none;
      box-sizing: border-box;
      position: relative;
      overflow: visible;
    }

    /* === HEADER TOP ROW (Logo + Title + Settings) === */
    .header-top {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }

    /* Animated scan line across header */
    header.app-header::before {
      display: none;
    }

    /* Corner accents */
    header.app-header::after {
      display: none;
    }

    /* === APP TITLE GROUP (logo + text) === */
    .app-title {
      display: flex;
      align-items: center;
      /* centers logo + text vertically */
      gap: 10px;
      font-weight: 700;
      color: #cccccc;
    }

    /* === LOGO WRAPPER === */
    .logo {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    /* === LOGO IMAGE === */
    .logo-img {
      height: 44px;
      width: auto;
      display: block;
      object-fit: contain;
      margin: 0;
      animation: none;
    }

    /* === MAIN TITLE (Refined Techy HUD Style, aligned & continuous) === */
    .main-title {
      font-size: 20px;
      font-family: Inter, "Segoe UI", sans-serif;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 1.3px;
      color: #cccccc;
      background: none;
      text-shadow: none;
      animation: none;
      position: relative;
      display: block;
      margin-left: 1px;
      line-height: 1.1;
      overflow: hidden;
      z-index: 1;
    }

    /* Continuous underline scan line (non-looping bounce) */
    .main-title::after {
      content: "";
      position: absolute;
      bottom: -1px;
      left: 0;
      height: 2px;
      width: 100%;
      background: none;
      animation: none;
      border-radius: 1px;
      opacity: 0;
      display: none;
    }

    /* === WARNING TEXT (aligned, modern subtle glow gradient) === */
    .warning-text {
      font-size: 11px;
      font-weight: 700;
      background: none;
      color: #888888;
      animation: none;
      text-shadow: none;
      margin-left: 1px;
      margin-top: 2px;
      line-height: 1.1;
      vertical-align: middle;
    }

    .header-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      position: relative;
      z-index: 2;
      flex-shrink: 0;
      margin-left: auto;
    }

    .search {
      width: 200px;
      background: #1a1a1a;
      border: 1px solid #333;
      padding: 6px 10px;
      border-radius: 2px;
      color: var(--text);
      font-size: 13px;
      box-shadow: none;
      transition: none;
    }

    .search:focus {
      outline: none;
      border-color: #333;
      box-shadow: none;
    }

    .search::placeholder {
      color: rgba(154, 166, 178, 0.6);
    }

    .settings {
      width: auto;
      height: auto;
      border: none;
      border-radius: 0;
      background: transparent;
      color: #9aa6b2;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 4px;
      transition: none;
      position: relative;
      z-index: 10001;
      padding: 0;
    }

    .settings::before,
    .settings::after {
      display: none;
    }

    .settings::before {
      display: none;
    }

    .settings .line {
      width: 24px;
      height: 2px;
      background-color: #9aa6b2;
      border-radius: 1px;
      transition: background-color 0.3s ease;
    }

    .settings:hover {
      color: #00f0ff;
    }

    .settings:hover .line {
      background-color: #00f0ff;
    }

    .settings:active {
      color: #9aa6b2;
    }

    .settings.active {
      color: #9aa6b2;
    }

    .settings.active .line {
      background-color: #9aa6b2;
    }

    .main {
      flex: 1 1 auto;
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 12px;
      min-height: 0;
    }

    @media (max-width: 768px) {

      /* Mobile Header: Logo+Title on top-left, Settings on top-right, Search below */
      header.app-header {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: flex-start;
      }

      .header-top {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1 0 auto;
        order: 1;
      }

      .app-title {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .logo-img {
        height: 36px !important;
      }

      .main-title {
        font-size: clamp(10px, 4vw, 16px) !important;
        letter-spacing: 0.5px !important;
        line-height: 1;
        display: inline !important;
        margin-left: 0 !important;
        margin-right: 4px;
      }

      .warning-text {
        font-size: clamp(8px, 3vw, 12px) !important;
        margin-top: 0 !important;
        display: inline;
        line-height: 1;
      }

      .header-controls {
        display: flex;
        width: 70%;
        gap: 8px !important;
        align-items: center;
        margin-left: 0 !important;
        flex-basis: 100%;
        order: 3;
      }

      .search-wrapper {
        flex: 1;
      }

      .search {
        width: 100%;
        padding: 6px 8px !important;
        font-size: 12px !important;
      }

      #settingsBtn {
        order: 2;
        flex-shrink: 0;
        margin-left: auto;
      }

      .main {
        display: grid !important;
        grid-template-columns: 1fr !important;
        grid-template-rows: auto auto auto !important;
        gap: 12px;
      }

      .right-column {
        display: contents;
      }

      #nextBoss {
        grid-row: 1 !important;
        grid-column: 1 !important;
      }

      #timersPanel {
        grid-row: 3 !important;
        grid-column: 1 !important;
        display: flex;
        flex: 0 0 auto;
        max-height: 25vh;
        min-height: 0;
        overflow: hidden;
      }

      #timers {
        max-height: 100%;
        flex: 1 1 auto;
        min-height: 0;
        overflow: auto;
      }

      #bossList {
        max-height: none;
        flex: 1 1 auto;
      }

      #bossListPanel {
        grid-row: 2 !important;
        grid-column: 1 !important;
        flex: 1 1 auto;
        min-height: 0;
        overflow: hidden;
      }

      #bossListPanel .card-header {
        min-height: 35px;
        padding: 8px 0;
        margin: 0;
        border-radius: var(--radius) var(--radius) 0 0;
      }

      /* Mobile: Smaller text and buttons */
      .boss .name {
        font-size: 0.75rem !important;
        letter-spacing: 0.3px !important;
      }

      .boss .sub {
        font-size: 9px !important;
      }

      .boss {
        padding: 3px 4px !important;
        font-size: 11px !important;
      }

      .kbtn {
        padding: 3px 4px !important;
        font-size: 10px !important;
        border-radius: 4px !important;
      }

      .timer {
        padding: 8px 10px !important;
        min-height: 50px !important;
        font-size: 10px !important;
        width: 98% !important;
        margin: 0 auto !important;
      }

      .timer-left {
        gap: 2px !important;
      }

      .timer-name {
        font-size: 12px !important;
      }

      .timer-spawn {
        font-size: 9px !important;
      }

      .timer-time {
        font-size: 10px !important;
      }

      .timer-content {
        padding: 4px 0 !important;
      }

      .timer-actions {
        gap: 4px !important;
      }

      .clear-timer-btn {
        padding: 4px 8px !important;
        font-size: 9px !important;
      }

      /* Mobile: Always show expanded section on timers */
      .timer-expanded {
        height: 18px !important;
        padding: 4px 10px 4px 0 !important;
        opacity: 1 !important;
        padding-left: 0 !important;
      }

      .timer {
        min-height: 60px !important;
      }

      .timer-remaining-label {
        font-size: 9px !important;
      }

      .timer-remaining-value {
        font-size: 9px !important;
      }

      #nextBoss {
        min-height: 75px !important;
        padding: 6px 8px !important;
      }

      #nextBoss .boss-name {
        font-size: 1.4rem !important;
      }

      #nextBoss .time-remaining {
        font-size: 0.85rem !important;
      }

      .card-header h2 {
        font-size: 14px !important;
      }

      /* Status icons smaller */
      .status-icon {
        width: 16px !important;
        height: 16px !important;
        font-size: 12px !important;
      }
    }

    .card {
      background: var(--panel-bg);
      border: 1px solid #222;
      border-radius: 4px;
      padding: 10px;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      min-height: 0;
      position: relative;
      overflow: visible;
    }

    .card::before {
      display: none;
    }

    .right-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
    }

    #bossList,
    #timers {
      flex: 1 1 auto;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      min-height: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 4px 2px;
      max-height: 100%;
      scroll-behavior: smooth;
    }

    /* === BOSS LIST === */
    .boss {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 95%;
      padding: 4px 6px;
      border-radius: 2px;
      background: var(--panel-bg);
      border: 1px solid #222;
      font-size: 12px;
      box-shadow: none;
      transition: background 0.35s ease-in-out, border-color 0.35s ease-in-out,
        transform 0.35s ease-in-out, box-shadow 0.35s ease-in-out;
      box-sizing: border-box;
      position: relative;
    }

    .boss::after {
      display: none;
    }

    .boss:hover {
      background: #1a1a1a;
      border-color: #222;
      transform: scale(1.04);
      box-shadow: 0 8px 24px rgba(0, 240, 255, 0.15);
    }

    .boss:hover::after {
      display: none;
    }

    /* Red accent for dead boss */
    .boss.is-dead {
      border-left: 4px solid rgba(239, 68, 68, 0.8) !important;
      padding-left: 4px !important;
    }

    /* Blue accent for alive boss */
    .boss.is-alive {
      border-left: 4px solid rgba(59, 130, 246, 0.8) !important;
      padding-left: 4px !important;
    }

    /* Red hover effect when boss is dead */
    .boss.is-dead:hover {
      background: rgba(239, 68, 68, 0.15) !important;
      border-color: rgba(239, 68, 68, 0.5) !important;
    }

    /* Blue hover effect when boss is alive */
    .boss.is-alive:hover {
      background: rgba(59, 130, 246, 0.15) !important;
      border-color: rgba(59, 130, 246, 0.5) !important;
    }

    .boss .meta {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    /* Normal (alive / cooldown) */
    .boss .name {
      font-family: Inter, "Segoe UI", sans-serif;
      color: #ffffff;
      font-weight: 900;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      text-shadow: none;
      transition: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      position: relative;
    }

    .boss .sub {
      font-size: 10px;
      color: var(--muted);
    }

    .kbtn {
      padding: 4px 6px;
      border-radius: 2px;
      border: 1px solid #333;
      background: #1a1a1a;
      color: var(--text);
      cursor: pointer;
      font-size: 11px;
      font-weight: 700;
      transition: none;
    }

    .kbtn:hover {
      background: #222;
      border-color: #333;
      color: var(--text);
    }

    /* Smaller delete button in active timers */
    .clear-timer-btn {
      padding: 4px 6px;
      font-size: 10px;
      border-radius: 2px;
      border: none;
      background: transparent;
      color: #999999;
    }

    .clear-timer-btn:hover {
      background: #222;
      border: 1px solid #333;
      color: var(--text);
    }

    /* === NEXT BOSS - CYBER HEXAGON THEME (reduced margins) === */
    #nextBoss {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 4px;

      /* √¢‚Ä†‚Äú Reduce space inside and outside √¢‚Ä†‚Äú */
      padding: 8px 12px;
      margin: 0;
      width: 100%;
      /* match timer width */
      min-height: 90px;
      /* taller panel */

      border-radius: 4px;
      border: 1px solid #222;
      border-right: 1px solid #222;
      background: var(--panel-bg);
      box-shadow: none;
      font-family: Inter, "Segoe UI", sans-serif;
      text-transform: none;
      letter-spacing: 1px;
      position: relative;
      overflow: visible;
    }

    #nextBoss::before {
      content: "";
      position: absolute;
      top: -2px;
      left: -100%;
      width: 100%;
      height: 4px;
      background: none;
      animation: none;
      display: none;
    }

    #nextBoss::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 10px;
      padding: 2px;
      background: none;
      -webkit-mask: none;
      mask: none;
      -webkit-mask-composite: unset;
      mask-composite: unset;
      animation: none;
      pointer-events: none;
      display: none;
    }

    /* === NEXT BOSS NAME: DARK MINIMALIST === */
    #nextBoss .boss-name {
      font-size: 1.8rem;
      font-weight: 900;
      color: #ff9500;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      display: inline-flex;
      align-items: center;
      position: relative;
      text-shadow: none;
      animation: none;
      z-index: 1;
      white-space: nowrap;
      flex-shrink: 0;
    }

    #nextBoss .time-remaining {
      font-size: 0.95rem;
      font-weight: 700;
      color: #999999;
      text-shadow: none;
      margin-top: 0;
      animation: none;
      z-index: 1;
      white-space: nowrap;
      flex-shrink: 1;
      min-width: 0;
    }

    /* === ACTIVE TIMER CARD √¢‚Ç¨‚Äù CYBER THEME === */
    .timer {
      position: relative;
      display: flex;
      flex-direction: column;
      width: 95%;
      border-radius: 2px;
      background: var(--panel-bg);
      border: 1px solid #222;
      font-size: 11px;
      box-shadow: none;
      transition: background 0.2s ease, border-color 0.2s ease,
        min-height 0.3s ease-out;
      overflow: hidden;
      height: auto;
      min-height: 48px;
    }

    .timer:hover {
      min-height: 70px;
    }

    .timer-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
    }

    .timer-expanded {
      height: 0;
      overflow: hidden;
      transition: height 0.3s ease-out, padding 0.3s ease-out,
        opacity 0.3s ease-out;
      padding: 0 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
    }

    .timer:hover .timer-expanded {
      height: 18px;
      padding: 4px 12px;
      opacity: 1;
    }

    .timer-remaining-label {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      font-size: 10px;
      color: #888888;
      font-weight: 500;
      letter-spacing: 0.3px;
      white-space: nowrap;
      line-height: 1;
      display: flex;
      align-items: baseline;
    }

    .timer-remaining-value {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      font-weight: 500;
      font-size: 10px;
      color: var(--accent);
      letter-spacing: 0.5px;
      white-space: nowrap;
      line-height: 1;
      display: flex;
      align-items: baseline;
      font-variant-numeric: tabular-nums;
      will-change: contents;
      min-width: 40px;
    }

    .timer::before {
      display: none;
    }

    .timer:hover::before {
      display: none;
    }

    /* Glow state √¢‚Ç¨‚Äù Ready to respawn */
    .timer.ready {
      border-color: #222;
      border-right-color: #222;
      border-left: 4px solid #22c55e;
      box-shadow: none;
      background: #1a1a1a;
      animation: none;
    }

    /* Timer layout */
    .timer-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
      flex: 1;
    }

    .timer-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      min-width: 100px;
    }

    .timer-actions {
      display: flex;
      gap: 2px;
    }

    /* === TIMER TEXT - CYBER THEME === */
    .timer .timer-name {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      font-weight: 600;
      font-size: 12px;
      color: #fff;
      letter-spacing: 0.5px;
    }

    .timer .timer-spawn {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      font-size: 10px;
      color: #888888;
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .timer .timer-remaining {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      font-weight: 500;
      font-size: 11px;
      color: var(--accent);
      letter-spacing: 0.5px;
    }

    /* Ready state - green glow */
    .timer.ready .timer-remaining {
      color: #00ff88;
      text-shadow: none;
      animation: none;
    }

    /* Hover */
    .timer:hover {
      background: rgba(255, 255, 255, 0.08) !important;
      border-color: rgba(255, 255, 255, 0.15) !important;
    }

    /* Preserve green left border on ready timer when hovered */
    .timer.ready:hover {
      border-left-color: #22c55e !important;
    }

    .timer:hover .timer-name {
      text-shadow: none;
    }

    /* Hover √¢‚Ç¨‚Äù bright neon red glow */
    .timer .kbtn:hover {
      background: #222;
      border-color: #333;
      color: var(--text);
    }

    /* Active press effect */
    .timer .kbtn:active {
      background: #1a1a1a;
    }

    @media (max-width: 900px) {

      html,
      body {
        height: 100% !important;
        overflow: hidden !important;
      }

      .container {
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .main {
        display: flex !important;
        flex-direction: column !important;
        flex: 1 1 auto;
        height: 100%;
        overflow: hidden !important;
        gap: 10px;
        /* match right-column gap */
      }

      .right-column {
        order: 0 !important;
        display: flex !important;
        flex-direction: column !important;
        gap: 10px;
        flex: 0 0 auto;
        width: 100%;
      }

      /* Stacking order */
      #nextBoss {
        order: 0 !important;
        flex: 0 0 auto !important;
        width: 100% !important;
      }

      /* Active timers √¢‚Ç¨‚Äù taller and directly √¢‚Ç¨≈ìtouching√¢‚Ç¨¬ù boss list */
      #timersPanel {
        display: flex;
        order: 2 !important;
      }

      /* Boss list √¢‚Ç¨‚Äù directly attached to timers */
      #bossListPanel {
        order: 1 !important;
        flex: 1 1 auto;
        width: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        margin: 0;
        padding: 0 10px 10px 10px;
        box-shadow: none;
      }

      /* Keep both panels the same background for seamless look */
      #timersPanel,
      #bossListPanel {
        background: var(--panel-bg);
        border: 1px solid #222;
      }

      /* Compact headers to minimize space */
      #timersPanel .card-header,
      #bossListPanel .card-header {
        min-height: 35px;
        padding: 8px 0;
        margin: 0;
        border-radius: var(--radius) var(--radius) 0 0;
      }

      /* Only the inner lists scroll */
      #timers,
      #bossList {
        flex: 1 1 auto;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 6px 4px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }

      /* Scrollbar */
      #bossList::-webkit-scrollbar,
      #timers::-webkit-scrollbar {
        width: 8px;
      }

      #bossList::-webkit-scrollbar-thumb,
      #timers::-webkit-scrollbar-thumb {
        background: rgba(0, 240, 255, 0.3);
        border-radius: 8px;
      }
    }

    /* === SETTINGS DROPDOWN === */
    .settings-dropdown {
      position: fixed;
      top: 65px;
      right: 12px;
      background: var(--panel-bg);
      border: 1px solid #222;
      border-radius: 4px;
      z-index: 10000;
      width: auto;
      display: block;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    .settings-dropdown.hidden {
      display: none;
    }

    .settings-modal {
      padding: 0 !important;
      width: auto !important;
      max-width: none !important;
    }

    .settings-list {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin: 0;
      border: none;
      border-radius: 0;
      overflow: hidden;
      background: transparent;
      padding: 4px 0;
    }

    .settings-item {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      padding: 7px 12px;
      background: transparent;
      border: none;
      border-bottom: 1px solid #1a1a1a;
      cursor: pointer;
      transition: background 0.15s ease;
      font-family: Inter, "Segoe UI", sans-serif;
      font-size: 12px;
      white-space: nowrap;
      color: #888888;
      position: relative;
    }

    .settings-item:last-child {
      border-bottom: none;
    }

    .settings-item:hover {
      background: #1a1a1a;
      color: #cccccc;
    }

    .settings-item .icon {
      font-size: 20px;
      flex-shrink: 0;
      filter: none;
      position: relative;
      z-index: 1;
      transition: none;
    }

    .settings-item:hover .icon {
      filter: none;
    }

    .settings-item .label {
      font-size: 11px;
      font-weight: 400;
      color: inherit;
      flex: 1;
    }

    .settings-item:active {
      background: #1a1a1a;
    }

    /* --- Compact Cyber Modal (Webhook window) --- */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: none;
      animation: none;
    }

    .modal-backdrop.active {
      display: flex;
    }

    @keyframes cyberFadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .modal {
      background: #0f0f0f;
      border: 1px solid #222;
      border-radius: 2px;
      box-shadow: none;
      padding: 22px 20px;
      width: 340px;
      max-width: 90%;
      color: var(--text);
      text-align: center;
      transform: none;
      opacity: 1;
      animation: none;
      backdrop-filter: none;
    }

    @keyframes cyberModalIn {
      0% {
        opacity: 0;
        transform: translateY(30px) scale(0.96);
        box-shadow: none;
      }

      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .modal h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #cccccc;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: none;
    }

    /* --- Webhook Input --- */
    #webhookInput {
      width: 100%;
      margin: 16px 0 18px 0;
      padding: 10px 12px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 2px;
      color: var(--text);
      font-family: Consolas, monospace;
      font-size: 12px;
      text-align: center;
      outline: none;
      transition: none;
      box-shadow: none;
    }

    #webhookInput::placeholder {
      color: #555;
      font-style: italic;
    }

    #webhookInput:focus {
      border-color: #333;
      box-shadow: none;
      background: #1a1a1a;
      color: var(--text);
      animation: none;
    }

    @keyframes inputPulse {

      0%,
      100% {
        box-shadow: 0 0 10px rgba(0, 240, 255, 0.4),
          inset 0 0 6px rgba(0, 240, 255, 0.2);
      }

      50% {
        box-shadow: 0 0 20px rgba(0, 240, 255, 0.8),
          inset 0 0 10px rgba(0, 240, 255, 0.35);
      }
    }

    /* --- Webhook Modal Buttons (SAVE, TEST, CLEAR) --- */
    #webhookModalBackdrop .modal-actions {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 8px;
    }

    #webhookSave,
    #webhookTest,
    #webhookClear {
      flex: 1;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #888888;
      font-weight: 700;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 2px;
      cursor: pointer;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      transition: none;
      box-shadow: none;
      backdrop-filter: none;
    }

    /* --- SAVE button --- */
    #webhookSave:hover {
      background: #222;
      color: #cccccc;
      border-color: #333;
    }

    #webhookSave:active {
      background: #1a1a1a;
    }

    /* --- TEST button --- */
    #webhookTest {
      border-color: #333;
      color: #888888;
      background: #1a1a1a;
    }

    #webhookTest:hover {
      background: #222;
      color: #cccccc;
    }

    /* --- CLEAR button --- */
    #webhookClear {
      border-color: #333;
      color: #888888;
      background: #1a1a1a;
    }

    #webhookClear:hover {
      background: #222;
      color: #cccccc;
    }

    #webhookClear:active {
      background: #1a1a1a;
    }

    .small {
      font-size: 12px;
      color: #888888;
    }

    /* === LOADING OVERLAY === */
    .loading-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      background: #000;
    }

    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .loading-hexagon {
      position: relative;
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hex-spinner {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    .hex-layer {
      display: none;
    }

    .hex-1,
    .hex-2,
    .hex-3 {
      display: none;
    }

    .loading-core {
      position: relative;
      width: 60px;
      height: 60px;
      z-index: 1;
    }

    .core-icon {
      width: 100%;
      height: 100%;
      animation: spinCore 1.5s linear infinite;
    }

    .core-ring {
      fill: none;
      stroke: #00f0ff;
      stroke-width: 2;
      opacity: 0.7;
    }

    .core-pulse {
      fill: none;
      stroke: #00f0ff;
      stroke-width: 1;
      opacity: 0.4;
    }

    .core-center {
      fill: #00f0ff;
    }

    @keyframes spinCore {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .loader-text {
      font-family: Inter, "Segoe UI", sans-serif;
      font-size: 1.2rem;
      font-weight: 700;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 4px;
      color: #00f0ff;
    }

    .loading-word {
      color: #00f0ff;
    }

    .loading-dots {
      display: flex;
      gap: 3px;
    }

    .loading-dots span {
      color: #00f0ff;
      animation: dotPulse 1s infinite;
    }

    .loading-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .loading-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes dotPulse {

      0%,
      100% {
        opacity: 0.3;
      }

      50% {
        opacity: 1;
      }
    }

    .loading-subtitle {
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 1px;
      color: #888888;
      text-transform: uppercase;
    }

    /* === CYBER POPUP: Set Time Modal === */
    #timeModal {
      position: fixed;
      inset: 0;
      display: none;
      /* JS toggles this */
      align-items: center;
      justify-content: center;
      z-index: 5000;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: none;
    }

    #timeModal .modal-content {
      background: #0f0f0f;
      border: 1px solid #222;
      border-radius: 2px;
      box-shadow: none;
      padding: 20px 18px;
      width: 340px;
      max-width: 90%;
      color: var(--text);
      text-align: center;
      animation: none;
      transform: none;
      font-family: Inter, "Segoe UI", sans-serif;
    }

    @keyframes popupRise {
      0% {
        opacity: 0;
        transform: translateY(18px) scale(0.98);
      }

      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    #timeModal h3 {
      font-size: 16px;
      color: #9aa6b2;
      margin: 0 0 10px 0;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: none;
    }

    #timeModal .modal-subtitle {
      font-size: 12px;
      color: #9aa6b2;
      margin-bottom: 14px;
      letter-spacing: 0.5px;
      text-transform: none;
      font-family: "Inter", sans-serif;
    }

    #killTimeInput {
      width: 100%;
      margin-bottom: 14px;
      padding: 10px 12px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 2px;
      color: var(--text);
      font-family: Consolas, monospace;
      font-size: 13px;
      text-align: center;
      outline: none;
      box-shadow: none;
      transition: all 0.2s ease;
    }

    #killTimeInput:focus {
      border-color: #333;
      box-shadow: none;
      background: #1a1a1a;
      color: var(--text);
    }

    #timeModal .actions {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 12px;
    }

    #timeModal .kbtn {
      flex: 1;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 2px;
      color: #9aa6b2;
      padding: 8px 10px;
      cursor: pointer;
      transition: none;
      box-shadow: none;
    }

    #timeModal .kbtn:hover {
      background: #222;
      border-color: #333;
      color: #9aa6b2;
    }

    #timeModal .kbtn:active {
      background: #1a1a1a;
    }

    /* Mobile tweak */
    @media (max-width: 420px) {
      #timeModal .modal-content {
        width: 92%;
        padding: 14px;
      }

      #killTimeInput {
        font-size: 14px;
        padding: 10px;
      }
    }

    .boss.shake {
      animation: none;
      z-index: 10;
      position: relative;
    }

    /* === DEAD BOSS === */
    /* Entire boss card gets different styling when dead */
    .boss:has(.name.dead) {
      background: #1a1a1a;
      border-color: #222;
      box-shadow: none;
      animation: none;
    }

    .boss:has(.name.dead)::after {
      display: none;
    }

    @keyframes deadCardPulse {

      0%,
      100% {
        box-shadow: 0 0 20px rgba(255, 68, 68, 0.15),
          inset 0 0 30px rgba(255, 68, 68, 0.05);
      }

      50% {
        box-shadow: 0 0 30px rgba(255, 68, 68, 0.25),
          inset 0 0 40px rgba(255, 68, 68, 0.1);
      }
    }

    .boss:has(.name.dead):hover {
      background: #1a1a1a;
      border-color: #222;
      box-shadow: none;
    }

    /* Dead boss portrait */
    .boss:has(.name.dead) .boss-portrait {
      border-color: #222;
      filter: none;
      box-shadow: none;
    }

    /* Dead boss name styling */
    .boss .name.dead {
      font-family: Inter, "Segoe UI", sans-serif;
      color: #888888;
      font-weight: 600;
      font-size: 0.95rem;
      letter-spacing: 1px;
      text-transform: uppercase;
      text-shadow: none;
      transition: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }

    /* Status badge */
    .boss .name.dead::before {
      display: none;
    }

    @keyframes badgeBlink {

      0%,
      100% {
        opacity: 0.8;
      }

      50% {
        opacity: 1;
      }
    }

    /* === CLEAN HEADERS: BOSS LIST & ACTIVE TIMERS (Responsive + Centered) === */
    .card-header {
      font-family: Inter, "Segoe UI", sans-serif;
      font-size: clamp(13px, 2vw, 16px);
      color: #888888;
      text-transform: none;
      letter-spacing: 1px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 35px;
      position: relative;
      overflow: visible;
      border-bottom: none;
      padding: 8px 0;
      text-shadow: none;
      box-sizing: border-box;
      margin: 0;
      width: 100%;
      /* no overflow */
    }

    /* --- Mobile refinement --- */
    @media (max-width: 720px) {
      .card-header {
        font-size: 13px;
        letter-spacing: 0.8px;
        padding: 8px 4px;
        min-height: 44px;
        text-align: center;
      }
    }

    .clear-icon {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      display: none;
      color: #9aa6b2;
      font-size: 14px;
      line-height: 1;
      transition: color 0.2s;
      user-select: none;
    }

    .clear-icon:hover {
      color: #9aa6b2;
    }

    /* === Custom Scrollbars for Boss List & Timers === */
    #bossList::-webkit-scrollbar,
    #timers::-webkit-scrollbar {
      width: 10px;
    }

    #bossList::-webkit-scrollbar-track,
    #timers::-webkit-scrollbar-track {
      background: rgba(0, 20, 30, 0.3);
      border-radius: 10px;
      border: 1px solid rgba(0, 240, 255, 0.1);
    }

    #bossList::-webkit-scrollbar-thumb,
    #timers::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
      box-shadow: none;
      transition: none;
    }

    #bossList::-webkit-scrollbar-thumb:hover,
    #timers::-webkit-scrollbar-thumb:hover {
      background: #444;
      box-shadow: none;
    }

    /* Firefox scrollbar customization */
    #bossList,
    #timers {
      scrollbar-width: thin;
      scrollbar-color: #333 #1a1a1a;
    }

    /* --- Online Users Indicator --- */
    .online-users {
      position: fixed;
      bottom: 14px;
      right: 16px;
      padding: 6px 10px;
      font-family: Consolas, monospace;
      font-size: 12px;
      color: #9aa6b2;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 2px;
      backdrop-filter: none;
      box-shadow: none;
      text-shadow: none;
      transition: none;
      animation: none;
      z-index: 3000;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* üü¢ Default icon */
    .online-users::before {
      content: "üü¢";
      margin-right: 4px;
      transition: none;
    }

    /* üí¨ replaces üü¢ when there's a new chat message */
    .online-users.notify::before {
      content: "üó®Ô∏è";
      color: #9aa6b2;
      text-shadow: none;
      animation: none;
    }

    /* Count text (only number updates via JS) */
    .online-users .count {
      font-weight: 600;
    }

    /* Hover effect */
    .online-users:hover {
      box-shadow: none;
      color: #9aa6b2;
    }

    /* Fade-in animation */
    @keyframes fadeInUsers {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* üí¨ red pulse animation */
    @keyframes pulseNotify {

      0%,
      100% {
        transform: scale(1);
        opacity: 0.9;
        text-shadow: 0 0 6px rgba(255, 80, 80, 0.9),
          0 0 12px rgba(255, 0, 0, 0.7), 0 0 18px rgba(255, 0, 0, 0.5);
      }

      50% {
        transform: scale(1.3);
        opacity: 1;
        text-shadow: 0 0 10px rgba(255, 100, 100, 1),
          0 0 20px rgba(255, 0, 0, 0.8), 0 0 30px rgba(255, 0, 0, 0.5);
      }
    }

    /* --- Tooltip: Softer Red Chat Bubble --- */
    .online-users::after {
      display: none;
    }

    /* Show tooltip when new message arrives */
    .online-users.notify::after {
      display: none;
    }

    /* Chat bubble tail */
    .online-users.notify::after::before {
      content: "";
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid #333;
      filter: none;
    }

    /* Tooltip glow animation */
    @keyframes tooltipPulse {

      0%,
      100% {
        box-shadow: 0 0 10px rgba(255, 80, 80, 0.4),
          0 0 18px rgba(255, 0, 0, 0.25);
      }

      50% {
        box-shadow: 0 0 14px rgba(255, 100, 100, 0.5),
          0 0 26px rgba(255, 0, 0, 0.35);
      }
    }

    /* --- Chat Box Styling --- */
    .chat-box {
      position: fixed;
      bottom: 50px;
      right: 16px;
      width: 300px;
      height: 350px;
      background: #0f0f0f;
      border: 1px solid #222;
      border-radius: 2px;
      box-shadow: none;
      transform: none;
      opacity: 1;
      transition: none;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 4000;
      backdrop-filter: none;
    }

    /* Open animation */
    .chat-box.active {
      transform: none;
      opacity: 1;
      box-shadow: none;
    }

    /* Fully hidden (when minimized) */
    .chat-box.hidden {
      transform: none;
      opacity: 0;
      pointer-events: none;
      transition: none;
    }

    /* --- Chat Header --- */
    .chat-header {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: Inter, "Segoe UI", sans-serif;
      background: #1a1a1a;
      color: #888888;
      padding: 8px 10px;
      text-align: center;
      font-size: 14px;
      letter-spacing: 1px;
      border-bottom: 1px solid #222;
      text-shadow: none;
      box-shadow: none;
    }

    /* --- Minimize Button --- */
    .chat-minimize-btn {
      position: absolute;
      right: 8px;
      top: 4px;
      background: #222;
      border: 1px solid #333;
      color: var(--accent);
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 2px;
      transition: none;
      text-shadow: none;
      box-shadow: none;
      backdrop-filter: none;
    }

    .chat-minimize-btn:hover {
      color: #9aa6b2;
      background: transparent;
      box-shadow: none;
    }

    /* --- Messages --- */
    .chat-messages {
      flex: 1;
      padding: 8px;
      overflow-y: auto;
      font-size: 12px;
      line-height: 1.4;
      color: var(--text);
      scrollbar-width: thin;
      scrollbar-color: #333 #1a1a1a;
    }

    /* Custom scrollbar (Chrome / Edge / Safari) */
    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 2px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 2px;
      box-shadow: none;
      transition: none;
    }

    .chat-messages::-webkit-scrollbar-thumb:hover {
      background: #444;
      box-shadow: none;
    }

    /* --- Each Message --- */
    .chat-message {
      margin-bottom: 6px;
      word-wrap: break-word;
    }

    /* --- Input Area --- */
    .chat-input-area {
      display: flex;
      padding: 6px;
      gap: 6px;
      border-top: 1px solid #222;
      background: #1a1a1a;
      backdrop-filter: none;
    }

    /* Input field */
    .chat-input-area input {
      flex: 1;
      padding: 6px 8px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 2px;
      color: var(--text);
      outline: none;
      transition: none;
    }

    .chat-input-area input:focus {
      border-color: #333;
      box-shadow: none;
      background: #1a1a1a;
    }

    /* Send button */
    .chat-input-area button {
      background: #1a1a1a;
      border: 1px solid #333;
      color: #9aa6b2;
      border-radius: 2px;
      cursor: pointer;
      padding: 0 10px;
      font-weight: 600;
      text-shadow: none;
      transition: none;
    }

    .chat-input-area button:hover {
      background: #222;
      border-color: #333;
      color: #9aa6b2;
    }

    .name-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .portrait-meta {
      display: flex;
      align-items: flex-end;
      gap: 10px;
    }

    .boss-portrait {
      width: 48px;
      height: 64px;
      object-fit: cover;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .boss-portrait:hover {
      transform: none;
      box-shadow: none;
    }

    .info {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .actions {
      display: grid;
      grid-template-columns: auto auto;
      align-items: center;
      gap: 10px;
      margin-top: 6px;
    }

    /* === ACTION BUTTONS - CYBER THEME === */
    .action-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      flex: 0 0 auto;
    }

    .action-btn.hidden {
      visibility: hidden;
    }

    .icon-btn {
      position: relative;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 2px;
      cursor: pointer;
      padding: 8px;
      color: #9aa6b2;
      transition: none;
      box-shadow: none;
      overflow: hidden;
    }

    .icon-btn::before {
      display: none;
    }

    .icon-btn:hover::before {
      display: none;
    }

    .icon-btn:hover {
      transform: none;
      border-color: #333;
      box-shadow: none;
      color: #9aa6b2;
    }

    .icon-btn:active {
      transform: none;
      box-shadow: none;
      background: #1a1a1a;
    }

    .icon-btn svg {
      position: relative;
      z-index: 1;
      filter: none;
    }

    .icon-btn:hover svg {
      filter: none;
    }

    /* Mark Dead Button - Minimal style */
    .icon-btn[data-action="mark"]:hover {
      border-color: #fbbf24;
      box-shadow: 0 0 12px rgba(251, 191, 36, 0.5);
      color: #fbbf24;
    }

    .icon-btn[data-action="mark"]:hover svg {
      filter: none;
    }

    .icon-btn[data-action="mark"]::before {
      display: none;
    }

    /* Set Timer Button - Minimal style */
    .icon-btn[data-action="set"]:hover {
      border-color: #22c55e;
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.5);
      color: #22c55e;
    }

    .icon-btn[data-action="set"]:hover svg {
      filter: none;
    }

    .icon-btn[data-action="set"]::before {
      display: none;
    }

    .icon-label {
      font-family: "Courier New", monospace;
      font-size: 9px;
      font-weight: 400;
      opacity: 0.8;
      text-transform: none;
      letter-spacing: 0.8px;
      color: #9aa6b2;
      text-shadow: none;
      transition: none;
    }

    .action-btn:hover .icon-label {
      opacity: 0.8;
      text-shadow: none;
      color: #9aa6b2;
    }
  </style>
</head>

<body>
  <div class="container">
    <header class="app-header">
      <div class="header-top">
        <div class="app-title">
          <div class="logo">
            <img alt="logo" class="logo-img"
              src="https://raw.githubusercontent.com/momowzen/DFck.LordnineSpawnTracker/refs/heads/main/assets/images/logo5.png" />
          </div>
          <div>
            <div class="main-title">FIELD BOSS TIME TRACKER</div>
            <div class="warning-text">FOR RICARDO01</div>
          </div>
        </div>
      </div>
      <div class="header-controls">
        <div class="search-wrapper" style="position: relative">
          <input class="search" id="bossSearch" placeholder="Search boss..." />
          <span class="clear-icon" id="clearSearch"> üóëÔ∏è </span>
        </div>
        <button aria-label="Settings" class="settings" id="settingsBtn">
          <span class="line"></span>
          <span class="line"></span>
          <span class="line"></span>
        </button>
      </div>
    </header>
    <main class="main">
      <section class="card" id="bossListPanel">
        <h4 class="card-header">BOSS LIST</h4>
        <div class="scrollable" id="bossList"></div>
      </section>
      <aside class="right-column">
        <div class="card" id="nextBoss">
          <div class="boss-name">Next Boss</div>
          <div class="time-remaining" id="nextTime">√¢‚Ç¨‚Äù √¢‚Ç¨‚Äù</div>
        </div>
        <section class="card" id="timersPanel">
          <h4 class="card-header">ACTIVE TIMERS</h4>
          <div class="scrollable" id="timers"></div>
        </section>
      </aside>
    </main>
  </div>
  <!-- Time modal (cyber-styled) -->
  <div aria-hidden="true" id="timeModal">
    <div aria-labelledby="modalBossName" aria-modal="true" class="modal-content" role="dialog">
      <h3 id="modalBossName"></h3>
      <div class="modal-subtitle">
        Set date and time of death (UTC+9 JST)
      </div>
      <input id="killTimeInput" type="datetime-local" />
      <div class="actions">
        <button class="kbtn" id="cancelTimeBtn">Cancel</button>
        <button class="kbtn" id="saveTimeBtn">Save</button>
      </div>
    </div>
  </div>
  <!-- Webhook modal √¢‚Ç¨‚Äù compact cyber panel -->
  <div class="modal-backdrop" id="webhookModalBackdrop">
    <div aria-labelledby="webhookTitle" aria-modal="true" class="modal cyber-modal" role="dialog">
      <h3 id="webhookTitle">üí¨ Discord Webhook</h3>
      <div class="small">Paste your Discord webhook URL below.</div>
      <input class="webhook-input" id="webhookInput" placeholder="Paste your Discord Webhook URL here." type="text" />
      <div class="modal-actions">
        <button class="cyber-btn" id="webhookSave">SAVE</button>
        <button class="cyber-btn" id="webhookTest">TEST</button>
        <button class="cyber-btn danger" id="webhookClear">CLEAR</button>
      </div>
    </div>
  </div>

  <div class="settings-dropdown hidden" id="settingsDropdown">
    <div aria-labelledby="settingsTitle" aria-modal="true" class="modal cyber-modal settings-modal" role="dialog">
      <div class="settings-list">
        <button class="settings-item" id="exportBtn">
          <span class="label">Export JSON</span>
        </button>
        <button class="settings-item" id="importBtn">
          <span class="label">Import JSON</span>
        </button>
        <button class="settings-item" id="resetBtn">
          <span class="label">Reset Timers</span>
        </button>
        <button class="settings-item" id="syncBtn">
          <span class="label">Sync Users</span>
        </button>
        <button class="settings-item" id="discordWebhookBtn">
          <span class="label">Webhook URL</span>
        </button>
      </div>
    </div>
  </div>
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-container">
      <div class="loading-hexagon">
        <div class="hex-spinner">
          <div class="hex-layer hex-1"></div>
          <div class="hex-layer hex-2"></div>
          <div class="hex-layer hex-3"></div>
        </div>
        <div class="loading-core">
          <svg viewBox="0 0 100 100" class="core-icon">
            <circle cx="50" cy="50" r="35" class="core-ring" />
            <circle cx="50" cy="50" r="25" class="core-pulse" />
            <circle cx="50" cy="50" r="15" class="core-center" />
          </svg>
        </div>
      </div>
      <div class="loader-text">
        <span class="loading-word">LOADING</span>
        <span class="loading-dots">
          <span>.</span><span>.</span><span>.</span>
        </span>
      </div>
      <div class="loading-subtitle">Initializing Tracker</div>
    </div>
  </div>

  <script type="module">
    // -------------------------
    // Data + constants (FULL BOSSES)
    // -------------------------
    const BOSSES = [
      { id: "Venatus", name: "Venatus", respawn: 60 * 60 * 10 },
      { id: "Viorent", name: "Viorent", respawn: 60 * 60 * 10 },
      { id: "Ego", name: "Ego", respawn: 60 * 60 * 21 },
      {
        id: "Clemantis",
        name: "Clemantis",
        weeklyRespawns: [
          { day: 1, hour: 12, minute: 30 },
          { day: 4, hour: 20, minute: 0 },
        ],
      },
      { id: "Livera", name: "Livera", respawn: 60 * 60 * 24 },
      { id: "Araneo", name: "Araneo", respawn: 60 * 60 * 24 },
      { id: "Undomiel", name: "Undomiel", respawn: 60 * 60 * 24 },
      {
        id: "Saphirus",
        name: "Saphirus",
        weeklyRespawns: [
          { day: 0, hour: 18, minute: 0 },
          { day: 2, hour: 12, minute: 30 },
        ],
      },
      {
        id: "Neutro",
        name: "Neutro",
        weeklyRespawns: [
          { day: 2, hour: 20, minute: 0 },
          { day: 4, hour: 12, minute: 30 },
        ],
      },
      { id: "LadyDalia", name: "Lady Dalia", respawn: 60 * 60 * 18 },
      {
        id: "GeneralAquleus",
        name: "General Aquleus",
        respawn: 60 * 60 * 29,
      },
      {
        id: "Thymele",
        name: "Thymele",
        weeklyRespawns: [
          { day: 1, hour: 20, minute: 0 },
          { day: 3, hour: 12, minute: 30 },
        ],
      },
      { id: "Amentis", name: "Amentis", respawn: 60 * 60 * 29 },
      {
        id: "BaronBraudmore",
        name: "Baron Braudmore",
        respawn: 60 * 60 * 32,
      },
      {
        id: "Milavy",
        name: "Milavy",
        weeklyRespawns: [{ day: 6, hour: 16, minute: 0 }],
      },
      { id: "Wannitas", name: "Wannitas", respawn: 60 * 60 * 48 },
      { id: "Metus", name: "Metus", respawn: 60 * 60 * 48 },
      { id: "Duplican", name: "Duplican", respawn: 60 * 60 * 48 },
      { id: "Shuliar", name: "Shuliar", respawn: 60 * 60 * 35 },
      {
        id: "Ringor",
        name: "Ringor",
        weeklyRespawns: [{ day: 6, hour: 18, minute: 0 }],
      },
      {
        id: "Roderick",
        name: "Roderick",
        weeklyRespawns: [{ day: 5, hour: 20, minute: 0 }],
      },
      { id: "Gareth", name: "Gareth", respawn: 60 * 60 * 32 },
      { id: "Titore", name: "Titore", respawn: 60 * 60 * 37 },
      { id: "Larba", name: "Larba", respawn: 60 * 60 * 35 },
      { id: "Catena", name: "Catena", respawn: 60 * 60 * 35 },
      {
        id: "Auraq",
        name: "Auraq",
        weeklyRespawns: [
          { day: 5, hour: 23, minute: 0 },
          { day: 3, hour: 22, minute: 0 },
        ],
      },
      { id: "Secreta", name: "Secreta", respawn: 60 * 60 * 62 },
      { id: "Ordo", name: "Ordo", respawn: 60 * 60 * 62 },
      { id: "Asta", name: "Asta", respawn: 60 * 60 * 62 },
      { id: "Supore", name: "Supore", respawn: 60 * 60 * 62 },
      {
        id: "Chaiflock",
        name: "Chaiflock",
        weeklyRespawns: [{ day: 6, hour: 23, minute: 0 }],
      },
      {
        id: "Benji",
        name: "Benji",
        weeklyRespawns: [{ day: 0, hour: 22, minute: 0 }],
      },
      //{ id: "Test Boss", name: "Test Boss", respawn: 60 * 5 + 10 },
    ];
    // -------------------------
    // DOM refs
    // -------------------------
    // Timezone configuration
    const TIME_ZONE = "Asia/Tokyo";
    const TIME_ZONE_LABEL = "UTC+9";
    const TIME_ZONE_ISO_SUFFIX = "+09:00";
    const TIME_ZONE_OFFSET_MS = 9 * 60 * 60 * 1000;
    const WEEKDAY_LABELS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const shortDateTimeFormatter = new Intl.DateTimeFormat("en-US", {
      timeZone: TIME_ZONE,
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
    const timeOnlyFormatter = new Intl.DateTimeFormat("en-US", {
      timeZone: TIME_ZONE,
      hour: "2-digit",
      minute: "2-digit",
      hour12: true,
    });
    const datetimeLocalFormatter = new Intl.DateTimeFormat("en-CA", {
      timeZone: TIME_ZONE,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    });

    const bossListEl = document.getElementById("bossList");
    const timersEl = document.getElementById("timers");
    const nextBossNameEl = document.querySelector("#nextBoss .boss-name");
    const nextTimeEl = document.getElementById("nextTime");
    const searchInput = document.getElementById("bossSearch");
    const clearSearch = document.getElementById("clearSearch");
    const searchWrapper = document.querySelector(".search-wrapper");
    const modal = document.getElementById("timeModal");
    const modalName = document.getElementById("modalBossName");
    const killTimeInput = document.getElementById("killTimeInput");
    const cancelTimeBtn = document.getElementById("cancelTimeBtn");
    const saveTimeBtn = document.getElementById("saveTimeBtn");
    const loadingOverlay = document.getElementById("loadingOverlay");
    const settingsBtn = document.getElementById("settingsBtn");
    const settingsDropdown = document.getElementById("settingsDropdown");
    const discordWebhookBtn = document.getElementById("discordWebhookBtn");
    const webhookBackdrop = document.getElementById("webhookModalBackdrop");
    const webhookInput = document.getElementById("webhookInput");
    const webhookSave = document.getElementById("webhookSave");
    const webhookTest = document.getElementById("webhookTest");
    const webhookClear = document.getElementById("webhookClear");
    if (killTimeInput) {
      killTimeInput.setAttribute(
        "aria-label",
        `Time of death in ${TIME_ZONE_LABEL}`
      );
      killTimeInput.setAttribute(
        "title",
        `All times are stored in ${TIME_ZONE_LABEL}`
      );
    }

    // -------------------------
    // State
    // -------------------------
    let firebaseLoaded = false;
    let cachedWebhookUrl = null;
    let timers = {}; // { bossId: { endTime, startedAt, weekly?, notifiedSoon?, spawnAnnounced? } }
    let currentBossForTime = null;
    let deadLocks = {}; // in-memory map of boss cooldowns

    // Dedup caches
    const lastWriteCache = {}; // { bossId: lastJson }
    const localNotifCache = {}; // { `${bossId}_${type}`: timestamp(ms) }

    // -------------------------
    // Helpers
    // -------------------------
    function sortActiveTimersSmoothly() {
      const timersContainer = document.getElementById("timers");
      if (!timersContainer) return;
      const timerCards = Array.from(timersContainer.children);
      timerCards.sort((a, b) => {
        const aTime = parseInt(a.dataset.remaining || 0);
        const bTime = parseInt(b.dataset.remaining || 0);
        return aTime - bTime;
      });
      let changed = false;
      for (let i = 0; i < timerCards.length; i++) {
        if (timersContainer.children[i] !== timerCards[i]) {
          changed = true;
          break;
        }
      }
      if (changed) {
        const fragment = document.createDocumentFragment();
        timerCards.forEach((card) => fragment.appendChild(card));
        timersContainer.appendChild(fragment);
      }
    }

    function formatSec(s) {
      if (s <= 0) return "Spawned";
      const d = Math.floor(s / 86400);
      s %= 86400;
      const h = Math.floor(s / 3600);
      s %= 3600;
      const m = Math.floor(s / 60);
      const sec = Math.floor(s % 60);
      if (d > 0)
        return `${d}d ${String(h).padStart(2, "0")}h ${String(m).padStart(
          2,
          "0"
        )}m`;
      if (h > 0)
        return `${String(h).padStart(2, "0")}h ${String(m).padStart(
          2,
          "0"
        )}m`;
      return `${String(m).padStart(2, "0")}m ${String(sec).padStart(
        2,
        "0"
      )}s`;
    }

    function formatWeeklyRespawnSlot(slot) {
      const day = WEEKDAY_LABELS[slot.day] ?? WEEKDAY_LABELS[0];
      return `${day} ${String(slot.hour).padStart(2, "0")}:${String(
        slot.minute
      ).padStart(2, "0")}`;
    }

    function ensureIsoHasSeconds(value) {
      if (!value) return "";
      if (/T\d{2}:\d{2}$/.test(value)) return `${value}:00`;
      return value;
    }

    function parseDatetimeLocalAsJst(value) {
      if (!value) return null;
      const normalized = ensureIsoHasSeconds(value);
      const hasZone = /([zZ]|[+-]\d{2}:\d{2})$/.test(normalized);
      const iso = hasZone ? normalized : `${normalized}${TIME_ZONE_ISO_SUFFIX}`;
      const parsed = new Date(iso);
      return isNaN(parsed) ? null : parsed;
    }

    function formatDatetimeLocalJst(ms) {
      if (!Number.isFinite(ms)) return "";
      const parts = datetimeLocalFormatter
        .formatToParts(ms)
        .reduce((acc, part) => {
          if (part.type !== "literal") acc[part.type] = part.value;
          return acc;
        }, {});
      if (!parts.year) return "";
      return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}`;
    }

    function formatShortDateTime(ms) {
      const formatted = shortDateTimeFormatter.format(ms);
      return formatted.replace(/\s{2,}/g, " ").replace(/\s*,\s*/g, ", ").trim();
    }

    function formatTimeOnly(ms) {
      return timeOnlyFormatter.format(ms);
    }

    function getNextWeeklyRespawn(respawns, fromTime = Date.now()) {
      const base = new Date(fromTime + TIME_ZONE_OFFSET_MS);
      let soonest = null;
      for (const { day, hour, minute } of respawns) {
        const candidate = new Date(base);
        const delta = (day + 7 - base.getUTCDay()) % 7;
        candidate.setUTCDate(base.getUTCDate() + delta);
        candidate.setUTCHours(hour, minute, 0, 0);
        const candidateUtc = candidate.getTime() - TIME_ZONE_OFFSET_MS;
        if (candidateUtc <= fromTime) {
          candidate.setUTCDate(candidate.getUTCDate() + 7);
        }
        const adjustedUtc = candidate.getTime() - TIME_ZONE_OFFSET_MS;
        if (!soonest || adjustedUtc < soonest) soonest = adjustedUtc;
      }
      return soonest ?? fromTime;
    }

    // ‚úÖ Import Firebase core and services
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
    import {
      getFirestore,
      doc,
      setDoc,
      getDoc,
      updateDoc,
      deleteDoc,
      deleteField,
      runTransaction,
      onSnapshot,
      serverTimestamp, // ‚úÖ Firestore FieldValue server timestamp (used in dedupe transaction)
    } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";

    import {
      getDatabase,
      ref,
      onDisconnect,
      onValue,
      set,
      push,
      serverTimestamp as rtdbServerTimestamp,
      onChildAdded,
      get, // ‚úÖ rename this one so you don√¢‚Ç¨‚Ñ¢t clash
    } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-database.js";

    // ‚úÖ Initialize Firebase app
    const firebaseConfig = {
      apiKey: "AIzaSyD9n0a6rQbt_M3J51pIILf-Ticjbttc3eg",
      authDomain: "lordnine-timer-9f21e.firebaseapp.com",
      databaseURL:
        "https://lordnine-timer-9f21e-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "lordnine-timer-9f21e",
      storageBucket: "lordnine-timer-9f21e.firebasestorage.app",
      messagingSenderId: "644000692891",
      appId: "1:644000692891:web:224bca1478655a43c0243e",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const rtdb = getDatabase(app);

    // ‚úÖ Firestore-based Global Synchronization
    let lastTriggeredBySelf = null;
    const syncBtn = document.getElementById("syncBtn");
    const refreshDocRef = doc(db, "meta", "refresh"); // Firestore doc for sync trigger

    // --- Trigger Sync ---
    syncBtn.addEventListener("click", async () => {
      settingsDropdown.classList.add("hidden");
      if (
        confirm(
          "Synchronize all clients? This will reload every user's page."
        )
      ) {
        const now = Date.now();
        lastTriggeredBySelf = now;
        await setDoc(refreshDocRef, { forceRefresh: now });
        alert("‚úÖ Synchronization triggered for all connected users.");
        console.log("üîÅ sync triggered at", new Date(now).toISOString());
      }
    });

    // --- Auto-refresh on Firestore update ---
    let hasInitialized = false;
    onSnapshot(refreshDocRef, (snapshot) => {
      const data = snapshot.data();
      if (!data) return;
      const lastTrigger = data.forceRefresh;
      const lastTriggerMs =
        lastTrigger && lastTrigger.toMillis
          ? lastTrigger.toMillis()
          : lastTrigger;

      if (!hasInitialized) {
        hasInitialized = true;
        return;
      }
      if (lastTriggerMs === lastTriggeredBySelf) return;

      console.log("√∞≈∏‚Äù‚Äû Firestore refresh triggered, reloading page.");
      location.reload();
    });

    // ‚úÖ Safe Firestore write helper √¢‚Ç¨‚Äù ensures reliable merges
    async function safeWrite(ref, payload) {
      try {
        await updateDoc(ref, payload);
      } catch (err) {
        console.warn("‚ö†Ô∏è  updateDoc failed, retrying with setDoc merge", err);
        await setDoc(ref, payload, { merge: true });
      }
    }

    // --- Load Discord webhook on startup (Firestore version) ---
    async function autoLoadWebhook() {
      try {
        const docRef = doc(db, "config", "discordWebhook");
        const snap = await getDoc(docRef);
        if (snap.exists()) {
          const data = snap.data();
          cachedWebhookUrl = data.url || null;
          console.log("‚úÖ Webhook loaded on startup:", cachedWebhookUrl);
        } else {
          console.warn("‚ö†Ô∏è  No webhook found in Firestore config.");
        }
      } catch (e) {
        console.error("‚ùå Failed to auto-load webhook:", e);
      }
    }

    // -------------------------
    // Webhook load/save/clear
    // -------------------------
    async function loadWebhookFromFirestore() {
      try {
        const docRef = doc(db, "config", "discordWebhook");
        const snap = await getDoc(docRef);
        if (snap.exists()) {
          const data = snap.data();
          cachedWebhookUrl = data.url || null;
          webhookInput.value = cachedWebhookUrl || "";
          console.log("‚úÖ Loaded webhook from Firestore.");
          return cachedWebhookUrl;
        } else {
          cachedWebhookUrl = null;
          webhookInput.value = "";
          console.log("√¢‚Äû¬π No webhook stored in Firestore.");
          return null;
        }
      } catch (e) {
        console.warn("load webhook err", e);
        return null;
      }
    }

    async function saveWebhookToFirestore(url) {
      try {
        await setDoc(doc(db, "config", "discordWebhook"), { url });
        cachedWebhookUrl = url;
        webhookInput.value = url;
        alert("‚úÖ Webhook saved.");
        console.log("‚úÖ Webhook saved to Firestore.");
      } catch (e) {
        console.warn("save webhook err", e);
        alert("‚ùå Failed to save webhook.");
      }
    }

    async function clearWebhookInFirestore() {
      try {
        await deleteDoc(doc(db, "config", "discordWebhook"));
        cachedWebhookUrl = null;
        webhookInput.value = "";
        alert("‚úÖ Webhook cleared.");
        console.log("‚úÖ Webhook cleared from Firestore.");
      } catch (e) {
        console.warn("clear webhook err", e);
        alert("‚ùå Failed to clear webhook.");
      }
    }

    // -------------------------
    // Discord send helpers
    // -------------------------
    async function sendDiscordEmbed(embed) {
      const webhook =
        cachedWebhookUrl ||
        (webhookInput && webhookInput.value.trim()) ||
        null;

      if (!webhook) {
        console.warn("‚ö†Ô∏è  No Discord webhook configured.");
        return;
      }

      const mentionTarget = "@everyone"; // no @everyone by default

      try {
        const payload = {
          content: mentionTarget,
          embeds: [embed],
        };

        const res = await fetch(webhook, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!res.ok) {
          console.error(
            "‚ùå Discord webhook failed:",
            res.status,
            await res.text()
          );
        } else {
          console.log("‚úÖ Discord embed sent successfully.");
        }
      } catch (err) {
        console.error("‚ö†Ô∏è  Discord webhook error:", err);
      }
    }

    // === patched sendDiscordEmbedOnce: normalized key + endTimeMs dedupe ===
    async function sendDiscordEmbedOnce(type, boss) {
      try {
        if (!boss || !type) return;

        // üîî Normalize Firestore key (handles spaces, punctuation)
        const safeId = encodeURIComponent(boss.id.trim());
        const key = `${safeId}_${type}`;

        const now = Date.now();
        const localWindow = 2 * 60 * 1000; // 2 min client dedupe

        // üîî Local dedupe guard (fast path)
        if (
          localNotifCache[key] &&
          now - localNotifCache[key] < localWindow
        ) {
          console.log(
            `√∞≈∏‚Ä∫‚Äò Locally skipped duplicate ${type} notification for ${boss.name}`
          );
          return;
        }

        // üîí Reserve locally
        localNotifCache[key] = now;
        console.log(`üîí Local reserve set for ${key}`);

        const ref = doc(db, "notifications", key);
        const thresholdMs = 2 * 60 * 1000; // server dedupe window

        const txResult = await runTransaction(db, async (tx) => {
          const snap = await tx.get(ref);
          const data = snap.exists() ? snap.data() : {};

          // Normalize timestamp formats
          let lastSentMs = 0;
          if (data.lastSent && typeof data.lastSent.toMillis === "function") {
            lastSentMs = data.lastSent.toMillis();
          } else if (typeof data.lastSent === "number") {
            lastSentMs = data.lastSent;
          } else if (typeof data.lastSent === "string") {
            const parsed = Date.parse(data.lastSent);
            if (!isNaN(parsed)) lastSentMs = parsed;
          }

          const lastEndTimeMs = data.lastEndTimeMs || 0;
          const thisEndTimeMs = timers[boss.id]?.endTime || 0;
          const nowMs = Date.now();

          // üîî Only skip if (a) last send < 2min ago AND (b) same spawn cycle
          const recentlySent =
            nowMs - lastSentMs < thresholdMs &&
            lastEndTimeMs === thisEndTimeMs;

          if (recentlySent) {
            console.log(
              `‚è∏Ô∏è Firestore dedupe prevented ${type} for ${boss.name} (same spawn cycle)`
            );
            return false;
          }

          // üîî Write both lastSent + lastEndTimeMs atomically
          tx.set(
            ref,
            {
              lastSent: serverTimestamp(),
              lastEndTimeMs: thisEndTimeMs,
              bossId: boss.id,
              type,
            },
            { merge: true }
          );

          return { endTimeMs: thisEndTimeMs };
        });

        if (!txResult) {
          console.log(
            `‚èπÔ∏è sendDiscordEmbedOnce: server dedupe prevented sending ${type} for ${boss.name}`
          );
          return;
        }

        const formattedTime = formatShortDateTime(
          txResult.endTimeMs || timers[boss.id]?.endTime || Date.now()
        );

        // üîî Build appropriate embed
        let embed;
        switch (type) {
          case "killed":
            embed = buildEmbed(
              `üíÄ ${boss.name} has been defeated!`,
              `Next respawn (${TIME_ZONE_LABEL}):\n${formattedTime}`,
              0xff3333,
              boss
            );
            break;

          case "soon":
            embed = buildEmbed(
              `‚ö†Ô∏è ${boss.name} will respawn soon!`,
              `Spawn expected in 5 minutes.\nSpawn Time (${TIME_ZONE_LABEL}):\n${formattedTime}`,
              0xffcc00,
              boss
            );
            break;

          case "spawn":
            embed = buildEmbed(
              `‚öîÔ∏è ${boss.name} has spawned!`,
              `It‚Äôs time to hunt!`,
              0xb266ff,
              boss
            );
            break;

          case "manual":
            embed = buildEmbed(
              `‚è∞ ${boss.name} manual time set.`,
              `Next respawn (${TIME_ZONE_LABEL}):\n${formattedTime}`,
              0x3399ff,
              boss
            );
            break;

          default:
            console.warn(`‚ö†Ô∏è Unknown notification type: ${type}`);
            return;
        }

        // üîî Final Discord send
        await sendDiscordEmbed(embed);
        console.log(`‚úÖ Sent ${type} notification for ${boss.name}`);
      } catch (e) {
        if (e?.code === "ABORTED") {
          console.warn("√¢‚Äû¬π Transaction aborted (expected):", e);
          return;
        }
        console.warn("‚ö†Ô∏è  sendDiscordEmbedOnce error:", e);
        delete localNotifCache[key]; // allow retry if failed
      }
    }

    function buildEmbed(title, description, colorHex, boss) {
      const embed = {
        title,
        description,
        color: colorHex,
        footer: { text: "Lordnine Tracker" },
        timestamp: new Date().toISOString(),
      };

      // Add boss image if boss object is provided
      if (boss && boss.id) {
        embed.thumbnail = {
          url: `https://raw.githubusercontent.com/momowzen/DFck.LordnineSpawnTracker/refs/heads/main/assets/images/${boss.id}.png`,
          height: 300,
          width: 300,
        };
      }

      return embed;
    }

    async function testWebhook() {
      if (!cachedWebhookUrl && !webhookInput.value.trim()) {
        alert("No webhook URL configured.");
        return;
      }
      if (!cachedWebhookUrl) cachedWebhookUrl = webhookInput.value.trim();
      // Use the first boss for test image
      const testBoss = BOSSES[0] || null;
      await sendDiscordEmbed(
        buildEmbed(
          "üß™ Webhook test successful!",
          "This is a test message from Lord Nine Tracker.",
          0x00ff99,
          testBoss
        )
      );
      alert("Test sent (check your Discord).");
    }

    // -------------------------
    // Firestore save dedupe helpers
    // -------------------------
    async function saveTimersToFirestore() {
      try {
        await setDoc(
          doc(db, "timers", "global"),
          { timers },
          { merge: true }
        );
        console.log("‚úÖ saveTimersToFirestore: saved timers document.");
      } catch (e) {
        console.warn("saveTimersToFirestore err", e);
      }
    }

    // Save or update a single boss timer in Firestore safely, with dedupe
    async function saveTimerToFirestoreOnce(bossId) {
      try {
        const ref = doc(db, "timers", "global");
        const data = timers[bossId];
        const json = JSON.stringify(data || {});
        if (lastWriteCache[bossId] === json) {
          console.log(`√¢‚Äû¬π Skipping redundant write for ${bossId}`);
          return;
        }
        lastWriteCache[bossId] = json;
        await safeWrite(ref, { [`timers.${bossId}`]: data });
        console.log(`‚úÖ saveTimerToFirestoreOnce: wrote timer for ${bossId}`);
      } catch (e) {
        console.warn("saveTimerToFirestoreOnce err", e);
      }
    }

    async function saveTimers() {
      try {
        await saveTimersToFirestore();
      } catch (e) {
        console.warn("saveTimers err", e);
      }
    }

    // -------------------------
    // Actions: start / clear / reset
    // -------------------------
    async function startTimer(bossId) {
      const boss = BOSSES.find((b) => b.id === bossId);
      if (!boss) return;
      const now = Date.now();
      let endTime;
      if (boss.weeklyRespawns) {
        endTime = getNextWeeklyRespawn(boss.weeklyRespawns);
        timers[bossId] = {
          endTime,
          startedAt: now,
          weekly: true,
          notifiedSoon: false,
          spawnAnnounced: false,
        };
      } else {
        endTime = now + boss.respawn * 1000;
        timers[bossId] = {
          endTime,
          startedAt: now,
          notifiedSoon: false,
          spawnAnnounced: false,
        };
      }

      // deduped write
      await saveTimerToFirestoreOnce(bossId);
      addOrUpdateTimerElement(bossId);
      renderBossList();

      console.log(
        `√∞≈∏‚Ä¢¬π startTimer: started ${bossId} -> ${new Date(
          timers[bossId].endTime
        ).toISOString()}`
      );

      // send killed embed (deduped)
      await sendDiscordEmbedOnce("killed", boss);
    }

    async function clearTimer(bossId) {
      const boss = BOSSES.find((b) => b.id === bossId);
      const ref = doc(db, "timers", "global");

      if (!timers[bossId]) {
        console.log(`√¢‚Äû¬π No timer to clear for ${boss?.name || bossId}.`);
        return;
      }

      delete timers[bossId]; // remove locally

      try {
        // Ensure the document exists first
        const snap = await getDoc(ref);
        if (!snap.exists()) {
          console.warn(
            "‚ö†Ô∏è  timers/global did not exist. Creating it first..."
          );
          await setDoc(ref, { timers: {} }, { merge: true });
        }

        // ‚úÖ Delete nested key with updateDoc and field path
        await updateDoc(ref, { [`timers.${bossId}`]: deleteField() });

        console.log(`‚úÖ clearTimer: removed ${bossId} from Firestore.`);
      } catch (err) {
        console.error("‚ùå Firestore delete failed for", bossId, err);
        alert("Failed to clear timer in Firestore. Please retry.");
      }

      // Update UI
      removeTimerElement(bossId);
      renderBossList();

      console.log(
        `√∞≈∏¬ß¬π Cleared timer for ${boss?.name || bossId} locally and remotely.`
      );
    }

    async function resetAll() {
      if (!confirm("Clear all non-weekly timers?")) return;
      const preserved = {};
      for (const [id, info] of Object.entries(timers)) {
        const boss = BOSSES.find((b) => b.id === id);
        if (boss && boss.weeklyRespawns) preserved[id] = info;
      }
      timers = preserved;

      try {
        await setDoc(doc(db, "timers", "global"), { timers }); // overwrite entire timers doc
        rebuildTimersPanel();
        renderBossList();
        alert("‚úÖ All non-weekly timers reset (Firestore updated).");
        console.log("üîÅ resetAll: fully reset timers and updated Firestore.");
      } catch (e) {
        console.warn("‚ùå resetAll Firestore update failed", e);
        alert("‚ö†Ô∏è  Failed to update Firestore.");
      }
    }

    // -------------------------
    // Modal for manual time
    // -------------------------
    function openTimeModal(bossId) {
      const boss = BOSSES.find((b) => b.id === bossId);
      if (!boss) return;
      currentBossForTime = boss;
      modalName.textContent = boss.name;
      const nowJstValue = formatDatetimeLocalJst(Date.now());
      killTimeInput.value = nowJstValue || "";
      modal.style.display = "flex";
    }

    function closeTimeModal() {
      modal.style.display = "none";
      currentBossForTime = null;
    }

    cancelTimeBtn.addEventListener("click", closeTimeModal);

    saveTimeBtn.addEventListener("click", async () => {
      const input = killTimeInput.value;
      if (!input || !currentBossForTime) return;

      const parsed = parseDatetimeLocalAsJst(input);
      if (!parsed) {
        alert("Invalid date format.");
        return;
      }

      const killedAt = parsed.getTime();
      const boss = currentBossForTime;
      let endTime;

      // ‚úÖ Calculate respawn
      if (boss.weeklyRespawns) {
        endTime = getNextWeeklyRespawn(boss.weeklyRespawns, killedAt + 1000);
        while (endTime <= killedAt) endTime += 7 * 24 * 60 * 60 * 1000;
        timers[boss.id] = {
          endTime,
          startedAt: killedAt,
          weekly: true,
          notifiedSoon: false,
          spawnAnnounced: false,
        };
      } else {
        endTime = killedAt + boss.respawn * 1000;
        timers[boss.id] = {
          endTime,
          startedAt: killedAt,
          notifiedSoon: false,
          spawnAnnounced: false,
        };
      }

      try {
        // ‚úÖ Ensure webhook is loaded before use
        if (!cachedWebhookUrl) await autoLoadWebhook();

        const ref = doc(db, "timers", "global");

        // ‚úÖ Correct Firestore structure
        await setDoc(
          ref,
          { timers: { [boss.id]: timers[boss.id] } },
          { merge: true }
        );

        console.log(`‚úÖ Firestore updated: ${boss.name} manual time saved.`);

        // ‚úÖ Update local UI
        closeTimeModal();
        addOrUpdateTimerElement(boss.id);
        renderBossList();

        // ‚úÖ Send Discord notification (manual entry always sends)
        const formattedTime = formatShortDateTime(endTime);
        const embed = buildEmbed(
          `‚è∞ ${boss.name} manual time set`,
          `Next respawn (${TIME_ZONE_LABEL}): ${formattedTime}`,
          0x3399ff,
          boss
        );
        await sendDiscordEmbedOnce("manual", boss);

        console.log(`√∞≈∏‚Äú¬° Discord notification sent for ${boss.name}.`);
        alert(`‚úÖ Manual time saved and synced for ${boss.name}.`);
      } catch (err) {
        console.error("‚ùå Failed to record manual time:", err);
        alert(
          "‚ùå Failed to record manual time to Firestore. Check console for details."
        );
      }
    });

    // -------------------------
    // Render functions
    // -------------------------
    function renderBossList() {
      bossListEl.innerHTML = "";
      const q = (searchInput.value || "").toLowerCase().trim();

      for (const b of BOSSES) {
        const isWeekly = !!b.weeklyRespawns;
        const isActive = timers[b.id] && timers[b.id].endTime > Date.now();
        if (q && !b.name.toLowerCase().includes(q)) continue;

        const subText = isWeekly
          ? `${b.weeklyRespawns.map(formatWeeklyRespawnSlot).join(", ")} ${TIME_ZONE_LABEL}`
          : b.respawn / 3600 + " hr";

        const node = document.createElement("div");
        node.className = isActive ? "boss is-dead" : "boss is-alive";

        const nameClass = isActive ? "name dead" : "name";

        node.innerHTML = `
					<div class="meta">
						<div class="portrait-meta">
							<img class="boss-portrait" src="https://raw.githubusercontent.com/momowzen/DFck.LordnineSpawnTracker/refs/heads/main/assets/images/${b.id
          }.png" alt="${b.name}">
							<div class="info">
								<div class="${nameClass}">${b.name}</div>
								<div class="sub">${subText}</div>
							</div>
						</div>
					</div>
					<div class="actions">
					<div class="action-btn ${isWeekly ? "hidden" : ""}">
					<button class="kbtn icon-btn" title="Manual Set" data-action="set" data-id="${b.id
          }">
					<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
					 stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
					<circle cx="12" cy="12" r="10"></circle>
					<polyline points="12 6 12 12 16 14"></polyline>
					</svg>
					</button>
					</div>

					<div class="action-btn">
					 <button class="kbtn icon-btn" title="Mark Dead" data-action="mark" data-id="${b.id
          }">
					 <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
					 stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
					<path d="M12 2C7 2 3 6 3 11c0 3 2 6 5 7v2c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2c3-1 5-4 5-7 0-5-4-9-9-9z"></path>
					<circle cx="9" cy="11" r="1"></circle>
					<circle cx="15" cy="11" r="1"></circle>
					</svg>
					</button>
					</div>
					</div>
					`;

        bossListEl.appendChild(node);
      }
    }

    // === Unified Boss List Click Handler with atomic deadlock attempt ===
    bossListEl.addEventListener("click", async (e) => {
      const btn = e.target.closest(".kbtn");
      if (!btn) return;

      // Prevent click event from bubbling to parent boss card
      e.stopPropagation();

      const action = btn.getAttribute("data-action");
      const id = btn.getAttribute("data-id");
      if (!id) return;

      if (action === "mark") {
        const now = Date.now();
        const lockDuration = 60 * 1000; // 1 minute
        const lockUntil = now + lockDuration;

        // Immediate visual disable to give feedback
        btn.disabled = true;
        console.log(
          `√∞≈∏‚ÄùÀú mark clicked: attempting lock for ${id} (local visual disabled)`
        );

        try {
          // Try atomic transaction to set lock only if not locked
          const locked = await runTransaction(db, async (tx) => {
            const snap = await tx.get(deadLockRef);
            const data = snap.exists() ? snap.data() : {};
            const existing = data[id] || 0;
            const tsNow = Date.now();

            if (existing && existing > tsNow) {
              // someone else holds lock
              return false;
            }
            // set lock
            tx.set(deadLockRef, { [id]: lockUntil }, { merge: true });
            return true;
          });

          if (!locked) {
            // lock lost to another client: re-enable and warn
            console.warn(
              `√¢‚Ä∫‚Äù markDead: failed to acquire lock for ${id} √¢‚Ç¨‚Äù another user locked it.`
            );
            // refresh deadLocks on next snapshot will correct disabled state, but re-enable for good UX
            btn.disabled = false;
            return;
          }

          // We acquired lock: update local memory immediately and disable all mark buttons for this boss
          deadLocks[id] = lockUntil;
          document
            .querySelectorAll(`.kbtn[data-id="${id}"][data-action="mark"]`)
            .forEach((b) => (b.disabled = true));
          console.log(
            `üîí Acquired lock for ${id} until ${new Date(
              lockUntil
            ).toISOString()}`
          );

          // Animate the boss card
          const card = btn.closest(".boss");
          if (card) {
            card.classList.add("shake");
            card.addEventListener(
              "animationend",
              () => card.classList.remove("shake"),
              { once: true }
            );
          }

          // Start the timer (this writes timer and triggers Discord send)
          await startTimer(id);
        } catch (err) {
          console.error("‚ö†Ô∏è  Error during mark dead transaction:", err);
          btn.disabled = false;
        }
        return;
      }

      if (action === "set") {
        openTimeModal(id);
      }
    });

    function addOrUpdateTimerElement(bossId) {
      const boss = BOSSES.find((b) => b.id === bossId);
      if (!boss) return;

      const info = timers[bossId];
      if (!info || !info.endTime) {
        return;
      }

      const existing = timersEl.querySelector(`.timer[data-id="${bossId}"]`);
      const remainingSec = Math.max(
        0,
        Math.round((info.endTime - Date.now()) / 1000)
      );
      const spawnStr = formatShortDateTime(info.endTime);
      const spawnLabel = `Spawn Time (${TIME_ZONE_LABEL}): ${spawnStr}`;

      if (existing) {
        existing.dataset.remaining = String(remainingSec);
        const nameEl = existing.querySelector(".timer-name");
        const spawnEl = existing.querySelector(".timer-spawn");
        const remainingValueEl = existing.querySelector(
          ".timer-remaining-value"
        );

        // Format remaining time using original format
        const remainingTimeStr = formatSec(remainingSec);

        if (nameEl) nameEl.textContent = boss.name;
        if (spawnEl) spawnEl.textContent = spawnLabel;
        if (remainingValueEl) remainingValueEl.textContent = remainingTimeStr;
        if (remainingSec === 0) existing.classList.add("ready");
        else existing.classList.remove("ready");
      } else {
        const node = document.createElement("div");
        node.className = "timer";
        node.dataset.id = bossId;
        node.dataset.remaining = String(remainingSec);

        // Format remaining time using original format
        const remainingTimeStr = formatSec(remainingSec);

        node.innerHTML = `
          <div class="timer-content">
            <div class="timer-left">
             <div class="timer-name">${boss.name}</div>
             <div class="timer-spawn">${spawnLabel}</div>
            </div>
            <div class="timer-actions">
             <button class="kbtn clear-timer-btn" data-id="${bossId}">Remove</button>
            </div>
          </div>
          <div class="timer-expanded">
            <span class="timer-remaining-label">Remaining Time:</span>
            <span class="timer-remaining-value">${remainingTimeStr}</span>
          </div>
          `;
        if (remainingSec === 0) node.classList.add("ready");
        timersEl.appendChild(node);

        // attach clear handler specifically for this timer's clear button
        node.querySelectorAll(".clear-timer-btn").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            const bid = e.currentTarget.getAttribute("data-id");
            if (bid) await clearTimer(bid);
          });
        });
      }
    }

    function removeTimerElement(bossId) {
      const el = timersEl.querySelector(`.timer[data-id="${bossId}"]`);
      if (el) el.remove();
    }

    function rebuildTimersPanel() {
      timersEl.innerHTML = "";
      const entries = Object.entries(timers)
        .map(([id, info]) => ({
          id,
          info,
          boss: BOSSES.find((b) => b.id === id),
        }))
        .filter((x) => x.boss)
        .sort((a, b) => a.info.endTime - b.info.endTime);
      for (const e of entries) addOrUpdateTimerElement(e.id);
      console.log("üîÅ rebuildTimersPanel: timers rendered.");
    }

    // -------------------------
    // Compute next boss helper
    // -------------------------
    function computeNextBoss() {
      const upcoming = Object.entries(timers)
        .map(([id, info]) => ({
          id,
          endTime: info.endTime,
          boss: BOSSES.find((b) => b.id === id),
        }))
        .filter((x) => x.boss)
        .sort((a, b) => a.endTime - b.endTime);

      if (upcoming.length === 0) {
        nextBossNameEl.textContent = "Next Boss: √¢‚Ç¨‚Äù";
        nextTimeEl.textContent = "√¢‚Ç¨‚Äù";
        return;
      }

      const soon = upcoming[0];
      const now = Date.now();
      const remainingMs = Math.max(0, soon.endTime - now);
      const totalSeconds = Math.floor(remainingMs / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = Math.floor(totalSeconds % 60);

      nextBossNameEl.textContent = `${soon.boss.name}`;
      if (totalSeconds === 0) {
        nextTimeEl.textContent = "SPAWNED";
      } else {
        nextTimeEl.textContent = `${String(hours).padStart(2, "0")}:${String(
          minutes
        ).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
      }

      // Auto-resize next boss name if it overflows
      adjustNextBossNameSize();
    }

    function adjustNextBossNameSize() {
      const nextBoss = document.getElementById("nextBoss");
      if (!nextBoss) return;

      const nameEl = nextBoss.querySelector(".boss-name");
      if (!nameEl) return;

      // Reset to default size
      nameEl.style.fontSize = "1.8rem";
      nameEl.style.letterSpacing = "1.5px";

      let fontSize = 1.8;
      const minFontSize = 0.9;
      const step = 0.1;

      // Reduce font size until text fits within the next boss panel
      while (fontSize > minFontSize) {
        nameEl.style.fontSize = fontSize + "rem";

        // Check if name is overflowing
        if (nameEl.scrollWidth <= nextBoss.clientWidth - 40) {
          // 40px padding buffer
          break;
        }

        fontSize -= step;
      }

      // If still overflowing, reduce letter-spacing
      if (
        fontSize <= minFontSize &&
        nameEl.scrollWidth > nextBoss.clientWidth - 40
      ) {
        nameEl.style.letterSpacing = "0.5px";
      }
    }

    // == MAIN TICKUPDATE == //
    async function tickUpdate() {
      const now = Date.now();
      const savePromises = [];

      for (const [id, info] of Object.entries(timers)) {
        const boss = BOSSES.find((b) => b.id === id);
        if (!boss) continue;

        // √∞≈∏‚Äò‚Ä° Determine current phase (active timer vs cooldown)
        const activeEndTime = info.cooldownUntil || info.endTime;
        const remainingMs = activeEndTime - now;

        const bossCard = document.querySelector(`.boss[data-id="${id}"]`);
        const nameElem = bossCard?.querySelector(".name");

        // --- (0) Handle cooldown visuals & skip logic during cooldown ---
        if (info.cooldownUntil && now < info.cooldownUntil) {
          // Ensure boss name shows alive look (no .dead)
          if (nameElem && nameElem.classList.contains("dead")) {
            nameElem.classList.remove("dead");
          }
          continue; // Skip further processing while cooldown active
        }

        // --- (1) Apply .dead automatically when timer is running ---
        if (remainingMs > 0 && !info.cooldownUntil) {
          if (nameElem && !nameElem.classList.contains("dead")) {
            nameElem.classList.add("dead");
          }
        }

        // --- (2) Soon warning (5 minutes before spawn) ---
        if (
          remainingMs <= 5 * 60 * 1000 &&
          remainingMs > 0 &&
          !info.notifiedSoon &&
          !info.cooldownUntil
        ) {
          console.log(`‚ö†Ô∏è  soon: ${id} within 5min, preparing notification`);
          info.notifiedSoon = true;
          savePromises.push(saveTimerToFirestoreOnce(id));
          savePromises.push(
            (async () => await sendDiscordEmbedOnce("soon", boss))()
          );
        }

        // --- (3) Spawn announcement when timer reaches 0 ---
        if (remainingMs <= 0 && !info.spawnAnnounced && !info.cooldownUntil) {
          console.log(`üéâ spawn: ${id} reached spawn, announcing`);
          info.spawnAnnounced = true;
          savePromises.push(saveTimerToFirestoreOnce(id));
          savePromises.push(
            (async () => await sendDiscordEmbedOnce("spawn", boss))()
          );
        }

        // --- (4) Start 3-minute cooldown when reaching 0 ---
        if (remainingMs <= 0 && !info.cooldownUntil) {
          info.cooldownUntil = now + 3 * 60 * 1000;
          console.log(
            `‚è≥ ${boss.name} entering 3-minute cooldown until ${formatTimeOnly(
              info.cooldownUntil
            )} ${TIME_ZONE_LABEL}`
          );

          // üü¢ Visual: back to normal white glow during cooldown
          if (nameElem) nameElem.classList.remove("dead");

          // üíæ Save cooldown state to Firestore
          savePromises.push(saveTimerToFirestoreOnce(id));
          continue;
        }

        // --- (5) Cooldown ended √¢‚Ç¨‚Äù restart timer automatically ---
        if (info.cooldownUntil && now >= info.cooldownUntil) {
          console.log(
            `‚úÖ ${boss.name} cooldown ended √¢‚Ç¨‚Äù restarting cycle...`
          );

          const nowLater = Date.now();
          let nextTime;

          if (boss.weeklyRespawns) {
            nextTime = getNextWeeklyRespawn(
              boss.weeklyRespawns,
              nowLater + 1
            );
            while (nextTime <= nowLater) nextTime += 7 * 24 * 60 * 60 * 1000;
          } else {
            nextTime = nowLater + boss.respawn * 1000;
          }

          // √¢‚Ñ¢¬ª Reset timer and clear cooldown
          timers[id] = {
            endTime: nextTime,
            startedAt: nowLater,
            weekly: !!boss.weeklyRespawns,
            notifiedSoon: false,
            spawnAnnounced: false,
            cooldownUntil: null,
          };

          // Apply .dead class again (timer active)
          if (nameElem && !nameElem.classList.contains("dead")) {
            nameElem.classList.add("dead");
          }

          await saveTimerToFirestoreOnce(id);
          addOrUpdateTimerElement(id);
          renderBossList();

          console.log(`üîÅ ${boss.name} timer restarted after cooldown.`);
          continue;
        }
      }

      // --- (6) Commit pending Firestore writes ---
      if (savePromises.length) {
        try {
          await Promise.all(savePromises);
          console.log(
            `üíæ tickUpdate: completed ${savePromises.length} save ops`
          );
        } catch (e) {
          console.warn("‚ö†Ô∏è  tickUpdate savePromises error", e);
        }
      }

      // --- (7) Update UI layout ---
      computeNextBoss();
      sortActiveTimersSmoothly();
    }

    // Optional lightweight visual update every second (no Firestore writes)
    function updateCountdownDisplay() {
      const now = Date.now();

      // Update active timers
      for (const [bossId, info] of Object.entries(timers)) {
        const el = document.querySelector(`.timer[data-id="${bossId}"]`);
        if (!el || !info?.endTime) continue;
        const remainingSec = Math.max(
          0,
          Math.round((info.endTime - now) / 1000)
        );
        const timeSpan = el.querySelector(".timer-remaining-value");
        if (timeSpan) timeSpan.textContent = formatSec(remainingSec);
        el.dataset.remaining = String(remainingSec);
        if (remainingSec === 0) el.classList.add("ready");
        else el.classList.remove("ready");
      }

      // Update next boss countdown
      computeNextBoss();
    }

    // fast visual refresh (every 1s, no Firestore writes)
    setInterval(updateCountdownDisplay, 1000);

    // slower background sync + notifications (every 1s)
    setInterval(() => {
      if (firebaseLoaded) tickUpdate();
    }, 1000);

    // -------------------------
    // UI wiring
    // -------------------------
    // Function to update clear button visibility
    const updateClearButtonVisibility = () => {
      const hasText = !!searchInput.value;
      clearSearch.style.display = hasText ? "inline" : "none";
      document
        .querySelector(".search-wrapper")
        ?.classList.toggle("has-text", hasText);
    };

    searchInput.addEventListener("input", () => {
      renderBossList();
      updateClearButtonVisibility();
    });

    // Keep clear button visible on focus/blur if text exists
    searchInput.addEventListener("focus", () => {
      updateClearButtonVisibility();
    });

    searchInput.addEventListener("blur", () => {
      updateClearButtonVisibility();
    });

    clearSearch.addEventListener("click", () => {
      searchInput.value = "";
      document.querySelector(".search-wrapper")?.classList.remove("has-text");
      updateClearButtonVisibility();
      renderBossList();
    });

    // Initialize on page load
    updateClearButtonVisibility();

    // === SETTINGS BUTTON + MODAL TOGGLE ===
    settingsBtn.addEventListener("click", (ev) => {
      ev.stopPropagation();
      settingsDropdown.classList.toggle("hidden");
      console.log(`‚öôÔ∏è¬è settings modal opened`);
    });

    document.addEventListener("click", (ev) => {
      if (
        !settingsBtn.contains(ev.target) &&
        !settingsDropdown.contains(ev.target)
      ) {
        settingsDropdown.classList.add("hidden");
      }
    });

    discordWebhookBtn.addEventListener("click", async (e) => {
      e.stopPropagation();
      settingsDropdown.classList.add("hidden");
      await loadWebhookFromFirestore();
      webhookBackdrop.style.display = "flex";
      console.log("√∞≈∏‚Äù¬ß open webhook modal");
    });

    webhookBackdrop.addEventListener("click", (ev) => {
      if (ev.target === webhookBackdrop)
        webhookBackdrop.style.display = "none";
    });

    const exportBtn = document.getElementById("exportBtn");
    const importBtn = document.getElementById("importBtn");
    const resetBtn = document.getElementById("resetBtn");

    exportBtn.addEventListener("click", () => {
      settingsDropdown.classList.add("hidden");
      try {
        const blob = new Blob([JSON.stringify(timers, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "boss_timers_backup.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert("‚úÖ Timers exported successfully.");
        console.log("√∞≈∏‚Äú¬§ Exported timers.json");
      } catch (e) {
        alert("‚ùå Failed to export timers.");
      }
    });

    importBtn.addEventListener("click", () => {
      settingsDropdown.classList.add("hidden");
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "application/json";
      input.onchange = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const text = await file.text();
        try {
          const imported = JSON.parse(text);
          if (
            confirm(
              "Import this JSON data? It will overwrite existing timers."
            )
          ) {
            timers = imported;
            await saveTimers();
            rebuildTimersPanel();
            renderBossList();
            alert("‚úÖ Timers imported successfully.");
            console.log("√∞≈∏‚Äú¬• Imported timers from file.");
          }
        } catch (e) {
          alert("‚ùå Invalid JSON file.");
        }
      };
      input.click();
    });

    resetBtn.addEventListener("click", () => {
      settingsDropdown.classList.add("hidden");
      if (confirm("Are you sure you want to reset all timers?")) resetAll();
    });

    // ‚úÖ Firestore document for lock management
    const deadLockRef = doc(db, "meta", "deadLocks");
    onSnapshot(deadLockRef, (snapshot) => {
      const data = snapshot.data() || {};
      deadLocks = data;
      const now = Date.now();

      document
        .querySelectorAll('.kbtn[data-action="mark"]')
        .forEach((btn) => {
          const bossId = btn.getAttribute("data-id");
          const lockedUntil = deadLocks[bossId] || 0;
          btn.disabled = now < lockedUntil;
        });

      console.log("üîî deadLocks updated from Firestore:", deadLocks);
    });

    // Periodically re-check (every 10s)
    setInterval(() => {
      const now = Date.now();
      document
        .querySelectorAll('.kbtn[data-action="mark"]')
        .forEach((btn) => {
          const bossId = btn.getAttribute("data-id");
          const lockedUntil = deadLocks[bossId] || 0;
          btn.disabled = now < lockedUntil;
        });
    }, 10000);

    webhookSave.addEventListener("click", async () => {
      const url = webhookInput.value.trim();
      if (!url) {
        alert("Please paste a webhook URL");
        return;
      }
      await saveWebhookToFirestore(url);
    });

    webhookTest.addEventListener("click", async () => {
      if (!cachedWebhookUrl) await loadWebhookFromFirestore();
      await testWebhook();
    });

    webhookClear.addEventListener("click", async () => {
      if (!confirm("Clear webhook from Firestore?")) return;
      await clearWebhookInFirestore();
    });

    // -------------------------
    // Init sequence
    // -------------------------
    async function init() {
      loadingOverlay.style.display = "flex";

      // ‚úÖ Wait until the DOM is fully loaded
      await new Promise((resolve) => {
        if (
          document.readyState === "complete" ||
          document.readyState === "interactive"
        )
          resolve();
        else
          document.addEventListener("DOMContentLoaded", resolve, {
            once: true,
          });
      });

      bossListEl.innerHTML = "";
      timersEl.innerHTML = "";
      nextBossNameEl.textContent = "";
      nextTimeEl.textContent = "";

      try {
        // ‚úÖ Firestore real-time listener (safe merge that respects cooldowns)
        const docRef = doc(db, "timers", "global");
        onSnapshot(docRef, async (snap) => {
          // ‚úÖ Auto-create if the timers document doesn√¢‚Ç¨‚Ñ¢t exist
          if (!snap.exists()) {
            console.log(
              "√¢‚Äû¬π No Firestore timers document found. Creating empty one..."
            );
            await setDoc(docRef, { timers: {} }, { merge: true });
            return;
          }

          const remoteTimers = snap.data().timers || {};
          const now = Date.now();

          // üîí Merge remote timers into local safely
          for (const [id, remoteInfo] of Object.entries(remoteTimers)) {
            const localInfo = timers[id] || {};
            const boss = BOSSES.find((b) => b.id === id);
            if (!boss) continue;

            // ‚úÖ If local cooldown is active, keep it √¢‚Ç¨‚Äù don√¢‚Ç¨‚Ñ¢t overwrite
            if (localInfo.cooldownUntil && localInfo.cooldownUntil > now) {
              console.log(
                `‚è∏Ô∏è ${boss.name} in local cooldown √¢‚Ç¨‚Äù preserving local timer.`
              );
              remoteTimers[id] = {
                ...remoteInfo,
                cooldownUntil: localInfo.cooldownUntil,
              };
              continue;
            }

            // ‚úÖ If remote has cooldown, preserve it too
            if (remoteInfo.cooldownUntil && remoteInfo.cooldownUntil > now) {
              console.log(`üíæ ${boss.name} cooldown synced from Firestore.`);
            }
          }

          timers = remoteTimers;

          rebuildTimersPanel();
          renderBossList();
          computeNextBoss();

          console.log("√∞≈∏‚Äù‚Äû Timers merged from Firestore:", timers);
        });
      } catch (e) {
        console.warn("Firestore load failed", e);
      }

      // ‚úÖ Normalize expired timers so everything is forward-looking (safe version)
      const now = Date.now();
      let timersChanged = false;

      for (const [id, info] of Object.entries(timers)) {
        const boss = BOSSES.find((b) => b.id === id);
        if (!boss || !info || !info.endTime) continue;

        // √∞≈∏≈°¬´ Skip normalization if cooldown is active
        if (info.cooldownUntil && info.cooldownUntil > now) {
          console.log(
            `‚è∏Ô∏è ${boss.name} still in cooldown √¢‚Ç¨‚Äù skipping normalization.`
          );
          continue;
        }

        // √∞≈∏¬ß¬≠ Normal advance logic for expired timers only
        if (info.endTime <= now) {
          if (boss.weeklyRespawns) {
            const next = getNextWeeklyRespawn(boss.weeklyRespawns, now + 1);
            timers[id] = {
              endTime: next,
              startedAt: now,
              weekly: true,
              notifiedSoon: false,
              spawnAnnounced: false,
              cooldownUntil: null,
            };
            timersChanged = true;
            console.log(`√∞≈∏¬ß¬≠ ${boss.name} normalized to next weekly cycle.`);
          } else if (boss.respawn) {
            const respMs = boss.respawn * 1000;
            const cycles = Math.floor((now - info.endTime) / respMs) + 1;
            const newEnd = info.endTime + cycles * respMs;
            timers[id] = {
              endTime: newEnd,
              startedAt: now,
              notifiedSoon: false,
              spawnAnnounced: false,
              cooldownUntil: null,
            };
            timersChanged = true;
            console.log(
              `√∞≈∏¬ß¬≠ ${boss.name} normalized to next respawn cycle.`
            );
          }
        }
      }

      // ‚úÖ Save normalized timers if any changed
      if (timersChanged) {
        try {
          await saveTimers();
          console.log("üîÅ Timers normalized and saved after init.");
        } catch (err) {
          console.error("‚ùå Failed to save normalized timers:", err);
        }
      }

      // ‚úÖ Ensure Discord webhook is ready before any future notification
      await autoLoadWebhook();

      firebaseLoaded = true;
      renderBossList();
      rebuildTimersPanel();
      computeNextBoss();
      loadingOverlay.style.display = "none";

      console.log("‚úÖ init completed successfully.");
    }

    window.addEventListener("load", () => init());

    // ‚úÖ Online presence tracking (Realtime Database)
    const presenceRef = ref(rtdb, "presence");
    const myConnection = push(presenceRef);
    set(myConnection, { connected: true, timestamp: rtdbServerTimestamp() });
    onDisconnect(myConnection).remove();

    // ‚úÖ Create or update the online users badge (üü¢ icon now handled by CSS)
    onValue(presenceRef, (snap) => {
      const count = snap.size || snap.numChildren();
      let el = document.getElementById("onlineCount");

      if (!el) {
        el = document.createElement("div");
        el.id = "onlineCount";
        el.classList.add("online-users");
        // üü¢ icon handled via CSS ::before √¢‚Ç¨‚Äù only insert count span here
        el.innerHTML = `<span class="count">${count}</span>`;
        document.body.appendChild(el);
      } else {
        const countSpan = el.querySelector(".count");
        if (countSpan && countSpan.textContent !== String(count)) {
          countSpan.textContent = count;
        }
      }
    });

    // === GLOBAL CHAT FUNCTIONALITY ===
    const chatBox = document.getElementById("chatBox");
    const chatMessages = document.getElementById("chatMessages");
    const chatInput = document.getElementById("chatInput");
    const chatSend = document.getElementById("chatSend");
    const chatMinimize = document.getElementById("chatMinimize");

    let lastSeenTimestamp = 0; // used to detect truly new messages
    let initialLoadComplete = false;

    // √∞≈∏¬ß¬† Generate random boss-based username (new each reload)
    function generateRandomUsername() {
      const prefixes = [
        "The",
        "Dark",
        "Crimson",
        "Iron",
        "Shadow",
        "Arcane",
        "Silent",
        "Ancient",
        "Eternal",
        "Solar",
        "Lunar",
        "Neon",
        "Fallen",
        "Cyber",
        "Storm",
        "Infernal",
        "Frozen",
        "Radiant",
        "Cursed",
        "Sacred",
        "Phantom",
        "Celestial",
        "Venomous",
        "Emerald",
        "Golden",
        "Azure",
        "Scarlet",
        "Mystic",
        "Quantum",
        "Obsidian",
        "Violet",
        "Titan",
        "Echo",
        "Prime",
        "Nova",
        "Omega",
        "Spectral",
        "Astral",
        "Dire",
        "Eclipse",
        "Wraith",
        "Void",
        "Ironclad",
        "Lucent",
        "Abyssal",
      ];

      const boss = BOSSES[Math.floor(Math.random() * BOSSES.length)];
      const prefix =
        Math.random() < 0.8
          ? prefixes[Math.floor(Math.random() * prefixes.length)] + " "
          : "";

      return prefix + boss.name;
    }

    const localUserName = generateRandomUsername();

    // ‚úÖ Wait until #onlineCount exists (created dynamically by Firebase)
    function attachChatToggle() {
      const onlineUsers = document.getElementById("onlineCount");
      if (!onlineUsers) return setTimeout(attachChatToggle, 300);

      onlineUsers.style.cursor = "pointer";

      // Clicking the online counter toggles chat open/close
      onlineUsers.addEventListener("click", () => {
        // If hidden (minimized), show it again
        if (chatBox.classList.contains("hidden")) {
          chatBox.classList.remove("hidden");
          chatBox.classList.add("active");
          onlineUsers.classList.remove("notify");
          lastSeenTimestamp = Date.now();
          return;
        }

        // If visible, hide it
        chatBox.classList.add("hidden");
        chatBox.classList.remove("active");
      });
    }
    attachChatToggle();

    // === Minimize Button Functionality ===
    if (chatMinimize) {
      chatMinimize.addEventListener("click", () => {
        chatBox.classList.add("hidden");
        chatBox.classList.remove("active");
      });
    }

    // Reference to chat messages in Firebase
    const chatRef = ref(rtdb, "globalChat");

    // √¢≈ì‚Ä∞ Send message
    chatSend.addEventListener("click", sendMessage);
    chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") sendMessage();
    });

    function sendMessage() {
      const text = chatInput.value.trim();
      if (!text) return;

      push(chatRef, { name: localUserName, text, timestamp: Date.now() });
      chatInput.value = "";

      // Update last seen when user sends (so they don√¢‚Ç¨‚Ñ¢t get notified of their own)
      lastSeenTimestamp = Date.now();
    }

    // üé® Generate a consistent glowing color per username
    function getUserColor(name) {
      if (name === localUserName) return "hsl(180, 80%, 70%)"; // your color: cyan-blue glow
      let hash = 0;
      for (let i = 0; i < name.length; i++) {
        hash = name.charCodeAt(i) + ((hash << 5) - hash);
      }
      const hue = Math.abs(hash) % 360;
      return `hsl(${hue}, 70%, 70%)`; // others: soft rainbow hues
    }

    // üí¨ Detect last message before user loads (to prevent false notifications)
    get(chatRef).then((snapshot) => {
      if (snapshot.exists()) {
        let latest = 0;
        snapshot.forEach((child) => {
          const data = child.val();
          if (data.timestamp > latest) latest = data.timestamp;
        });
        lastSeenTimestamp = latest;
      }
      initialLoadComplete = true;
    });

    // üí¨ Listen for incoming messages
    onChildAdded(chatRef, (snapshot) => {
      const data = snapshot.val();
      const msgEl = document.createElement("div");
      msgEl.className = "chat-message";

      const userColor = getUserColor(data.name);
      const time = `${formatTimeOnly(data.timestamp)} ${TIME_ZONE_LABEL}`;

      msgEl.innerHTML = `
					<strong style="
						color: ${userColor};
						text-shadow: 0 0 8px ${userColor};
					">${data.name}</strong>
					<small style="opacity: 0.7;">[${time}]</small>:
					<span style="
						color: ${userColor};
						text-shadow: 0 0 6px ${userColor};
					">${data.text}</span>
				`;

      chatMessages.appendChild(msgEl);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      // Ignore notifications before initial load
      if (!initialLoadComplete) return;

      // Only notify for messages newer than last seen
      if (data.timestamp <= lastSeenTimestamp) return;

      // üîî Show visual notification & tooltip if chat is closed
      const onlineUsers = document.getElementById("onlineCount");
      if (onlineUsers && !chatBox.classList.contains("active")) {
        if (!onlineUsers.classList.contains("notify")) {
          onlineUsers.classList.add("notify");

          // small bounce animation
          onlineUsers.animate(
            [
              { transform: "translateY(0)" },
              { transform: "translateY(-4px)" },
              { transform: "translateY(0)" },
            ],
            { duration: 300, easing: "ease-out" }
          );
        }
      }
    });

    // Auto-refresh the page every 5 minutes
    setTimeout(() => {
      location.reload();
    }, 300000); // 300,000 ms = 5 minutes
  </script>

  <!-- Chat Box (hidden by default) -->
  <div id="chatBox" class="chat-box hidden">
    <div class="chat-header">
      SERVER CHAT
      <button id="chatMinimize" class="chat-minimize-btn">‚àí</button>
    </div>

    <div id="chatMessages" class="chat-messages"></div>

    <div class="chat-input-area">
      <input id="chatInput" type="text" placeholder="Type a message..." />
      <button id="chatSend">Send</button>
    </div>
  </div>
</body>

</html>
